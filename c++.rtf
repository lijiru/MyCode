{\rtf1\ansi\ansicpg936\cocoartf1265\cocoasubrtf190
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;\f1\fnil\fcharset134 STHeitiSC-Light;\f2\fswiss\fcharset0 Helvetica;
}
{\colortbl;\red255\green255\blue255;\red0\green116\blue0;\red100\green56\blue32;\red196\green26\blue22;
\red170\green13\blue145;\red28\green0\blue207;\red63\green110\blue116;\red38\green71\blue75;\red46\green13\blue110;
\red92\green38\blue153;}
\paperw11900\paperh16840\margl1440\margr1440\vieww19720\viewh12300\viewkind0
\deftab770
\pard\tx770\pardeftab770\pardirnatural

\f0\fs32 \cf2 \CocoaLigature0 //
\f1 \'c9\'e8\'d6\'c3\'c6\'c1\'c4\'bb\'b4\'f3\'d0\'a1\'ce\'aa
\f0 480*320\cf0 \
    \cf2 //CCEGLView::sharedOpenGLView()->setDesignResolutionSize(480,320, kResolutionExactFit);\
\

\f1\fs24 \'cb\'ce\'cc\'e5
\f2 	SimSun\

\f1 \'ba\'da\'cc\'e5
\f2 	SimHei\

\f1 \'ce\'a2\'c8\'ed\'d1\'c5\'ba\'da
\f2 	Microsoft YaHei\

\f1 \'ce\'a2\'c8\'ed\'d5\'fd\'ba\'da\'cc\'e5
\f2 	Microsoft JhengHei\

\f1 \'d0\'c2\'cb\'ce\'cc\'e5
\f2 	NSimSun\

\f1 \'d0\'c2\'cf\'b8\'c3\'f7\'cc\'e5
\f2 	PMingLiU\

\f1 \'cf\'b8\'c3\'f7\'cc\'e5
\f2 	MingLiU\

\f1 \'b1\'ea\'bf\'ac\'cc\'e5
\f2 	DFKai-SB\

\f1 \'b7\'c2\'cb\'ce
\f2 	FangSong\

\f1 \'bf\'ac\'cc\'e5
\f2 	KaiTi\

\f1 \'b7\'c2\'cb\'ce
\f2 _GB2312	FangSong_GB2312\

\f1 \'bf\'ac\'cc\'e5
\f2 _GB2312	KaiTi_GB2312\
\

\f1 \'cb\'ce\'cc\'e5\'a3\'ba
\f2 SimSuncss
\f1 \'d6\'d0\'d6\'d0\'ce\'c4\'d7\'d6\'cc\'e5\'a3\'a8
\f2 font-family
\f1 \'a3\'a9\'b5\'c4\'d3\'a2\'ce\'c4\'c3\'fb\'b3\'c6
\f2 \
Mac OS
\f1 \'b5\'c4\'d2\'bb\'d0\'a9\'a3\'ba
\f2 \

\f1 \'bb\'aa\'ce\'c4\'cf\'b8\'ba\'da\'a3\'ba
\f2 STHeiti Light [STXihei]\

\f1 \'bb\'aa\'ce\'c4\'ba\'da\'cc\'e5\'a3\'ba
\f2 STHeiti\

\f1 \'bb\'aa\'ce\'c4\'bf\'ac\'cc\'e5\'a3\'ba
\f2 STKaiti\

\f1 \'bb\'aa\'ce\'c4\'cb\'ce\'cc\'e5\'a3\'ba
\f2 STSong\

\f1 \'bb\'aa\'ce\'c4\'b7\'c2\'cb\'ce\'a3\'ba
\f2 STFangsong\

\f1 \'83\'ab\'ba\'da
\f2  Pro
\f1 \'a3\'ba
\f2 LiHei Pro Medium\

\f1 \'83\'ab\'cb\'ce
\f2  Pro
\f1 \'a3\'ba
\f2 LiSong Pro Light\

\f1 \'98\'cb\'bf\'ac\'f3\'77\'a3\'ba
\f2 BiauKai\

\f1 \'cc\'4f\'b9\'fb\'83\'ab\'d6\'d0\'ba\'da\'a3\'ba
\f2 Apple LiGothic Medium\

\f1 \'cc\'4f\'b9\'fb\'83\'ab\'bc\'9a\'cb\'ce\'a3\'ba
\f2 Apple LiSung Light\
Windows
\f1 \'b5\'c4\'d2\'bb\'d0\'a9\'a3\'ba
\f2 \

\f1 \'d0\'c2\'bc\'9a\'c3\'f7\'f3\'77\'a3\'ba
\f2 PMingLiU\

\f1 \'bc\'9a\'c3\'f7\'f3\'77\'a3\'ba
\f2 MingLiU\

\f1 \'98\'cb\'bf\'ac\'f3\'77\'a3\'ba
\f2 DFKai-SB\

\f1 \'ba\'da\'cc\'e5\'a3\'ba
\f2 SimHei\

\f1 \'d0\'c2\'cb\'ce\'cc\'e5\'a3\'ba
\f2 NSimSun\

\f1 \'b7\'c2\'cb\'ce\'a3\'ba
\f2 FangSong\

\f1 \'bf\'ac\'cc\'e5\'a3\'ba
\f2 KaiTi\

\f1 \'b7\'c2\'cb\'ce
\f2 _GB2312
\f1 \'a3\'ba
\f2 FangSong_GB2312\

\f1 \'bf\'ac\'cc\'e5
\f2 _GB2312
\f1 \'a3\'ba
\f2 KaiTi_GB2312\

\f1 \'ce\'a2\'dc\'9b\'d5\'fd\'ba\'da\'f3\'77\'a3\'ba
\f2 Microsoft JhengHei\

\f1 \'ce\'a2\'c8\'ed\'d1\'c5\'ba\'da\'cc\'e5\'a3\'ba
\f2 Microsoft YaHei\

\f1 \'d7\'b0
\f2 Office
\f1 \'bb\'e1\'c9\'fa\'b3\'f6\'c0\'b4\'b5\'c4\'d2\'bb\'d0\'a9\'a3\'ba
\f2 \

\f1 \'c1\'a5\'ca\'e9\'a3\'ba
\f2 LiSu\

\f1 \'d3\'d7\'d4\'b2\'a3\'ba
\f2 YouYuan\

\f1 \'bb\'aa\'ce\'c4\'cf\'b8\'ba\'da\'a3\'ba
\f2 STXihei\

\f1 \'bb\'aa\'ce\'c4\'bf\'ac\'cc\'e5\'a3\'ba
\f2 STKaiti\

\f1 \'bb\'aa\'ce\'c4\'cb\'ce\'cc\'e5\'a3\'ba
\f2 STSong\

\f1 \'bb\'aa\'ce\'c4\'d6\'d0\'cb\'ce\'a3\'ba
\f2 STZhongsong\

\f1 \'bb\'aa\'ce\'c4\'b7\'c2\'cb\'ce\'a3\'ba
\f2 STFangsong\

\f1 \'b7\'bd\'d5\'fd\'ca\'e6\'cc\'e5\'a3\'ba
\f2 FZShuTi\

\f1 \'b7\'bd\'d5\'fd\'d2\'a6\'cc\'e5\'a3\'ba
\f2 FZYaoti\

\f1 \'bb\'aa\'ce\'c4\'b2\'ca\'d4\'c6\'a3\'ba
\f2 STCaiyun\

\f1 \'bb\'aa\'ce\'c4\'e7\'fa\'e7\'ea\'a3\'ba
\f2 STHupo\

\f1 \'bb\'aa\'ce\'c4\'c1\'a5\'ca\'e9\'a3\'ba
\f2 STLiti\

\f1 \'bb\'aa\'ce\'c4\'d0\'d0\'bf\'ac\'a3\'ba
\f2 STXingkai\

\f1 \'bb\'aa\'ce\'c4\'d0\'c2\'ce\'ba\'a3\'ba
\f2 STXinwei\
\cf0 \CocoaLigature1 \

\f0\fs32 \cf3 \CocoaLigature0 #include \cf4 "HelloWorldScene.h"\cf3 \
#include \cf4 "TestLayer.h"\cf3 \
\cf0 USING_NS_CC;\
\
CCScene* HelloWorld::scene()\
\{\
    CCScene *scene = CCScene::create();\
    HelloWorld *layer = HelloWorld::create();\
    scene->addChild(layer);\
    \cf5 return\cf0  scene;\
\}\
\
\cf2 //
\f1 \'b3\'f5\'ca\'bc\'bb\'af
\f0 \cf0 \
\cf5 bool\cf0  HelloWorld::init()\
\{\
    \cf5 if\cf0  ( !CCLayer::init() )\
    \{\
        \cf5 return\cf0  \cf5 false\cf0 ;\
    \}\
    \
    CCSize s = CCDirector::sharedDirector()->getWinSize();\
   \
    CCNode * node = CCNode::create();\cf2 //
\f1 \'bf\'c9\'d2\'d4\'d7\'f7\'ce\'aa\'c8\'dd\'c6\'f7
\f0 \cf0 \
    node->setPosition(\cf6 100\cf0 , \cf6 100\cf0 );\
    \
\cf2 //    //
\f1 \'b4\'b4\'bd\'a8\'be\'ab\'c1\'e9
\f0 \cf0 \
\cf2 //    CCSprite * sp = CCSprite::create("Icon-114.png");\cf0 \
\cf2 //    sp->setPosition(ccp(s.width/2, s.height/2));\cf0 \
\cf2 //    sp->setAnchorPoint(ccp(0,0));//
\f1 \'c3\'aa\'b5\'e3\'a3\'ac\'c4\'ac\'c8\'cf\'ce\'aa\'d6\'d0\'d0\'c4\'ce\'bb\'d6\'c3\'bc\'b0
\f0  ccp
\f1 \'a3\'a8
\f0 0.5
\f1 \'a3\'ac
\f0 0.5
\f1 \'a3\'a9
\f0 \cf0 \
\cf2 //    sp->setScale(1.5);   //
\f1 \'cb\'f5\'b7\'c5\'b1\'c8\'c0\'fd\'a3\'bb
\f0 \cf0 \
\cf2 //    sp->setRotation(90);   //
\f1 \'d0\'fd\'d7\'aa\'a3\'ac\'cb\'b3\'ca\'b1\'d5\'eb\'ce\'aa\'d5\'fd\'a3\'ac\'c4\'e6\'ca\'b1\'d5\'eb\'ce\'aa\'b8\'ba\'a3\'ac\'b4\'f3\'d3\'da
\f0 360
\f1 \'c4\'ac\'c8\'cf\'ce\'aa
\f0 360\cf0 \
\cf2 //    node->addChild(sp);\cf0 \
\cf2 //    \cf0 \
\cf2 //    CCSprite * sp1 = CCSprite::create("HelloWorld.png");\cf0 \
\cf2 //    sp1->setPosition(ccp(s.width/2, s.height/2));\cf0 \
\cf2 //    node->addChild(sp1,-1);//
\f1 \'c4\'ac\'c8\'cf\'ce\'aa
\f0 0
\f1 \'a3\'ac
\f0 -1
\f1 \'b2\'bb\'b8\'b2\'b8\'c7\'b5\'da\'d2\'bb\'d5\'c5\'cd\'bc\'c6\'ac
\f0 \cf0 \
\cf2 //    \cf0 \
    \cf5 this\cf0 ->addChild(node);\
    \
    \cf5 int\cf0  i = \cf6 0\cf0 ;\
    CCLog(\cf4 "123456"\cf0 );\
    CCLog(\cf4 ">>>>>>>>> %d"\cf0 ,i);\
    \
    \
    \cf2 //
\f1 \'b0\'b4\'c5\'a5
\f0 \cf0 \
    CCMenuItemImage * image = CCMenuItemImage::create(\cf4 "CloseNormal.png"\cf0 ,\cf4 "CloseSelected.png"\cf0 );\
    image->setPosition(ccp(\cf6 200\cf0 , \cf6 200\cf0 ));\
    image->setTag(\cf6 13\cf0 );\
    \
    image->setTarget(\cf5 this\cf0 , menu_selector(HelloWorld::menuCloseCallback));\
    \
    CCMenuItemImage * image1 = CCMenuItemImage::create(\cf4 "CloseNormal.png"\cf0 ,\cf4 "CloseSelected.png"\cf0 );\
    image1->setPosition(ccp(\cf6 100\cf0 , \cf6 200\cf0 ));\
    image1->setTag(\cf6 12\cf0 );\
    image1->setTarget(\cf5 this\cf0 , menu_selector(HelloWorld::menuCloseCallback));\
    \
    \cf2 //this->addChild(image, 5);\cf0 \
    CCMenu * menu = CCMenu ::create(image,image1,\cf5 NULL\cf0 );\
    menu->setPosition(CCPointZero );\
    \cf5 this\cf0 ->addChild(menu,-\cf6 1\cf0 );\
    \
    \
    \cf2 //
\f1 \'c9\'e8\'d6\'c3\'d1\'d5\'c9\'ab
\f0 \cf0 \
    CCLayerColor * color = CCLayerColor::create(ccc4(\cf6 100\cf0 ,\cf6 150\cf0 ,\cf6 90\cf0 ,\cf6 100\cf0 ),\cf6 200\cf0 ,\cf6 300\cf0 ); \cf2 //255:
\f1 \'c9\'ee\'ba\'ec\'a3\'ac
\f0 160
\f1 \'a3\'ba\'d6\'d0\'ba\'ec
\f0 \cf0 \
    color->setAnchorPoint(CCPointZero);\
    color->ignoreAnchorPointForPosition(\cf5 false\cf0 );\
    \cf5 this\cf0 ->addChild(color);\
    \
    HelloWorld::testArray();\
    testDictionary();\
    \
    \
    \cf2 //
\f1 \'b6\'a8\'ca\'b1\'c6\'f7
\f0 \cf0 \
    \cf2 //
\f1 \'b5\'f7\'d3\'c3
\f0  scheduleUpdate 
\f1 \'b5\'c4\'ca\'b1\'ba\'f2
\f0 ,
\f1 \'cf\'b5\'cd\'b3\'c4\'ac\'c8\'cf\'c3\'bf\'d6\'a1\'c8\'a5\'b5\'f7\'d3\'c3
\f0  update 
\f1 \'ba\'af\'ca\'fd
\f0 \cf0 \
    \cf5 this\cf0 ->scheduleUpdate();\
    \
    \cf2 //
\f1 \'b5\'f7\'d3\'c3\'d7\'d4\'bc\'ba\'b5\'c4\'b8\'fc\'d0\'c2\'b7\'bd\'b7\'a8
\f0 ,
\f1 \'c3\'bf\'d2\'bb\'d6\'a1\'b8\'fc\'d0\'c2\'d2\'bb\'b4\'ce
\f0 \cf0 \
    \cf2 //
\f1 \'d5\'e6\'d5\'fd\'b4\'b4\'bd\'a8\'d2\'bb\'b8\'f6\'b6\'a8\'ca\'b1\'c6\'f7
\f0 ,
\f1 \'d0\'de\'b8\'c4\'d2\'bb\'cf\'c2
\f0  schedule 
\f1 \'b5\'c4\'b2\'ce\'ca\'fd\'be\'cd\'bf\'c9\'d2\'d4\'c1\'cb
\f0 \cf0 \
    \cf5 this\cf0 ->schedule(schedule_selector(HelloWorld::myUpdate),\cf6 2.0f\cf0 );\
    \cf2 //
\f1 \'b5\'da\'b6\'fe\'b8\'f6\'b2\'ce\'ca\'fd\'b5\'c4\'d2\'e2\'cb\'bc\'ca\'c7
\f0 ,
\f1 \'c3\'bf\'b8\'f4\'b6\'e0\'c9\'d9\'c3\'eb\'d6\'b4\'d0\'d0\'d2\'bb\'b4\'ce
\f0  MutUpdate 
\f1 \'ba\'af\'ca\'fd
\f0 ,
\f1 \'bc\'c7\'d7\'a1
\f0 ,
\f1 \'b5\'a5\'ce\'bb\'ca\'c7\'c3\'eb\'a1\'a3
\f0 2.0f
\f1 \'b1\'ed\'ca\'be\'c1\'bd\'c3\'eb\'b5\'f7\'d3\'c3\'d2\'bb\'b4\'ce
\f0 myUpdate\cf0 \
    \cf5 this\cf0 ->scheduleOnce(schedule_selector(HelloWorld::myUpdate), \cf6 1.0f\cf0 );\
    \
    \cf2 //
\f1 \'b1\'ea\'c7\'a9
\f0 \cf0 \
    CCLabelTTF * lable = CCLabelTTF::create(\cf4 "Text"\cf0 , \cf4 "Arial"\cf0 , \cf6 20\cf0 );\
    lable->setPosition(ccp(\cf6 450\cf0 ,\cf6 600\cf0 ));\
    \cf5 this\cf0 ->addChild(lable);\
    \
    \cf5 return\cf0  \cf5 true\cf0 ;\
\}\
\
\
   \
\cf2 //
\f1 \'c3\'bf\'d2\'bb\'d6\'a1\'d6\'b4\'d0\'d0\'d2\'bb\'b4\'ce\'a3\'ac\'cb\'f9\'d3\'d0\'d6\'a1\'c1\'ac\'bd\'d3\'c6\'f0\'c0\'b4\'d0\'ce\'b3\'c9\'b6\'af\'bb\'ad
\f0 \cf0 \
\cf5 void\cf0  HelloWorld::update(\cf5 float\cf0  dt)\
\{\
    CCLog(\cf4 "update:%f"\cf0 ,dt);\
    \cf2 //
\f1 \'c8\'e7\'b9\'fb\'ca\'c7\'d2\'aa\'c8\'a1\'cf\'fb\'c4\'ac\'c8\'cf\'b5\'c4
\f0  update 
\f1 \'ba\'af\'ca\'fd\'b5\'f7\'d3\'c3
\f0 ,
\f1 \'d2\'b2\'ba\'dc\'bc\'f2\'b5\'a5
\f0 :\cf0 \
    \cf5 this\cf0 -> unscheduleUpdate();\
    \cf2 //
\f1 \'c8\'a1\'cf\'fb\'ba\'cd\'d7\'a2\'b2\'e1\'ca\'c7\'b6\'d4\'d3\'a6\'b5\'c4\'a1\'a3
\f0 \cf0 \
\}\
\cf2 //
\f1 \'d7\'d4\'bc\'ba\'b5\'c4
\f0 \cf0 \
\cf5 void\cf0  HelloWorld::myUpdate(\cf5 float\cf0  dt)\
\{\
    CCLog(\cf4 "MyUpdate:%f"\cf0 ,dt);\
    \cf2 //this->unscheduleAllSelectors();\cf0 \
    \
    \cf5 this\cf0 ->unschedule(schedule_selector(HelloWorld::myUpdate));\
    \cf2 //unschedule,
\f1 \'b9\'cb\'c3\'fb\'cb\'bc\'d2\'e5\'c1\'cb
\f0 ,un 
\f1 \'d2\'bb\'b0\'e3\'ca\'c7\'b4\'fa\'b1\'ed\'c8\'a1\'cf\'fb\'b5\'c4\'d2\'e2\'cb\'bc\'a1\'a3\'b5\'ab\'ca\'c7\'d2\'aa\'d7\'a2\'d2\'e2\'d2\'bb\'b5\'e3
\f0 , 
\f1 \'b2\'bb\'b9\'dc\'ce\'d2\'c3\'c7\'d7\'a2\'b2\'e1
\f0  update 
\f1 \'ba\'af\'ca\'fd\'b5\'c4\'ca\'b1\'ba\'f2
\f0 ,
\f1 \'d3\'c3\'b5\'c4\'ca\'c7\'d2\'bb\'b8\'f6\'b2\'ce\'ca\'fd
\f0 ,
\f1 \'bb\'b9\'ca\'c7\'c1\'bd\'b8\'f6\'b2\'ce\'ca\'fd
\f0 ,
\f1 \'d4\'da\'c8\'a1\'cf\'fb\'b5\'c4
\f0  
\f1 \'ca\'b1\'ba\'f2\'b6\'bc\'ca\'c7\'b2\'bb\'d0\'e8\'d2\'aa\'b4\'ab\'c6\'e4\'cb\'fb\'b2\'ce\'ca\'fd\'b5\'c4
\f0 ,
\f1 \'d6\'bb\'d2\'aa\'b4\'ab\'b5\'dd\'ba\'af\'ca\'fd\'be\'cd
\f0  OK 
\f1 \'c1\'cb\'a1\'a3
\f0 \cf0 \
\}\
\
\
\cf2 //
\f1 \'bb\'e6\'d6\'c6\'b7\'bd\'b7\'a8\'a3\'ac\'c3\'bf\'d2\'bb\'d6\'a1\'b6\'bc\'bb\'e1\'d7\'d4\'b6\'af\'b5\'f7\'d3\'c3
\f0 \cf0 \
\cf5 void\cf0  HelloWorld::draw()\
\{\
    CCSize s = CCDirector::sharedDirector()->getWinSize();\
    \
    \cf2 //openGl
\f1 \'bb\'e6\'cd\'bc
\f0 \cf0 \
    \
    \cf2 //
\f1 \'bb\'e6\'d6\'c6\'d6\'b1\'cf\'df
\f0 \cf0 \
    glLineWidth(\cf6 5.0f\cf0 );\
    ccDrawColor4B(\cf6 255\cf0 , \cf6 0\cf0 , \cf6 0\cf0 , \cf6 255\cf0 );\
    ccDrawLine(ccp(\cf6 0\cf0 , s.height), ccp(s.width,\cf6 0\cf0 ));\
    \
    \cf2 //
\f1 \'bb\'e6\'d6\'c6\'d4\'b2
\f0 \cf0 \
    glLineWidth(\cf6 2\cf0 );\
    ccDrawColor4B(\cf6 0\cf0 , \cf6 255\cf0 , \cf6 0\cf0 , \cf6 255\cf0 );\
    ccDrawCircle(ccp(s.width/\cf6 2\cf0 , s.height/\cf6 2\cf0 ), \cf6 50\cf0 , CC_DEGREES_TO_RADIANS(\cf6 120\cf0 ), \cf6 50\cf0 , \cf5 false\cf0 , \cf6 1\cf0 , \cf6 1\cf0 );\
    \cf2 //
\f1 \'d6\'d0\'d0\'c4\'b5\'e3\'a1\'a2\'b0\'eb\'be\'b6\'a1\'a2\'bd\'c7\'b6\'c8\'a1\'a2\'b7\'d6\'b6\'ce\'ca\'fd\'a1\'a2\'ca\'c7\'b7\'f1\'c1\'ac\'bd\'d3\'d6\'d0\'d0\'c4\'b5\'e3\'a1\'a2
\f0 x
\f1 \'d6\'e1\'b7\'bd\'cf\'f2\'b5\'c4\'cb\'f5\'b7\'c5\'a3\'ac
\f0 y
\f1 \'d6\'e1\'b7\'bd\'cf\'f2\'b5\'c4\'cb\'f5\'b7\'c5
\f0 \cf0 \
    \
    \cf2 //
\f1 \'bb\'e6\'d6\'c6\'b5\'e3
\f0 \cf0 \
    CCPoint points[] = \{ccp(\cf6 60\cf0 ,\cf6 60\cf0 ),ccp(\cf6 70\cf0 , \cf6 70\cf0 ),ccp(\cf6 60\cf0 , \cf6 70\cf0 ),ccp(\cf6 70\cf0 , \cf6 60\cf0 )\};\
    ccPointSize(\cf6 4\cf0 );\
    ccDrawColor4B(\cf6 0\cf0 , \cf6 0\cf0 , \cf6 255\cf0 , \cf6 255\cf0 );\
    ccDrawPoints(points,\cf6 4\cf0 );\
    \
    \cf2 //
\f1 \'bb\'ad\'b6\'e0\'b1\'df\'d0\'ce
\f0 \cf0 \
    ccDrawColor4B(\cf6 255\cf0 , \cf6 255\cf0 , \cf6 0\cf0 , \cf6 255\cf0 );\
    glLineWidth(\cf6 2\cf0 );\
    CCPoint vertices[] =\{ccp(\cf6 30\cf0 ,\cf6 130\cf0 ),ccp(\cf6 30\cf0 , \cf6 230\cf0 ),ccp(\cf6 50\cf0 , \cf6 200\cf0 )\};\
    ccDrawPoly(vertices, \cf6 3\cf0 , \cf5 true\cf0 );\cf2 //fales 
\f1 \'b2\'bb\'b1\'d5\'ba\'cf
\f0 \cf0 \
    \
    \cf2 //
\f1 \'bb\'ad\'b1\'b4\'c8\'fb\'b6\'fb\'c7\'fa\'cf\'df
\f0 \cf0 \
    \cf2 //
\f1 \'ba\'af\'ca\'fd\'b5\'c4\'b5\'da\'d2\'bb\'b8\'f6\'b2\'ce\'ca\'fd\'ce\'aa\'d2\'bb\'b8\'f6\'bf\'d8\'d6\'c6\'b5\'e3\'a3\'ac\'b5\'da\'b6\'fe\'b8\'f6\'ba\'cd\'b5\'da\'c8\'fd\'b8\'f6\'ce\'aa\'c1\'bd\'b8\'f6\'bf\'d8\'d6\'c6\'b5\'e3\'a3\'ac\'d7\'ee\'ba\'f3\'d2\'bb\'b8\'f6\'b2\'ce\'ca\'fd\'ce\'aa\'b7\'d6\'b6\'ce\'ca\'bd\'a3\'ac\'c8\'e7\'b4\'fa\'c2\'eb\'c7\'e5\'b5\'a5\'cb\'f9\'ca\'be
\f0 \cf0 \
    CHECK_GL_ERROR_DEBUG();\cf2 //
\f1 \'d5\'e2\'b8\'f6\'ba\'ea\'b6\'a8\'d2\'e5\'d2\'bb\'b8\'f6\'ba\'af\'ca\'fd\'a3\'ac\'be\'cd\'ca\'c7\'c8\'e7\'b9\'fb\'d3\'d0\'b4\'ed\'ce\'f3\'a3\'ac\'be\'cd\'ca\'e4\'b3\'f6\'b4\'ed\'ce\'f3\'d0\'c5\'cf\'a2
\f0 \cf0 \
    ccDrawQuadBezier(ccp(\cf6 0\cf0 ,s.height), ccp(s.width/\cf6 2\cf0 ,s.height/\cf6 2\cf0 ), ccp(s.width,s.height), \cf6 50\cf0 );\
    CHECK_GL_ERROR_DEBUG();\
    \
    \cf2 //
\f1 \'bb\'e6\'d6\'c6\'c1\'a2\'cc\'e5\'b5\'c4
\f0 \cf0 \
    ccDrawCubicBezier(ccp(s.width/\cf6 2\cf0 ,s.height/\cf6 2\cf0 ), ccp(s.width/\cf6 2\cf0 +\cf6 30\cf0 ,s.height/\cf6 2\cf0 +\cf6 50\cf0 ), ccp(s.width/\cf6 2\cf0 +\cf6 60\cf0 ,s.height/\cf6 2\cf0 -\cf6 50\cf0 ), ccp(s.width,s.height/\cf6 2\cf0 ), \cf6 100\cf0 );\
\
    \
\}\
\
\cf2 //
\f1 \'ca\'fd\'d7\'e9
\f0 \cf0 \
\cf5 void\cf0  HelloWorld::testArray()\
\{\
    CCString * str1 = CCString::create(\cf4 "String1"\cf0 );\
    CCString * str2 = CCString::create(\cf4 "String2"\cf0 );\
    CCString * str3 = CCString::create(\cf4 "String3"\cf0 );\
    CCString * str4 = CCString::create(\cf4 "String4"\cf0 );\
    CCString * str5 = CCString::create(\cf4 "String5"\cf0 );\
    CCString * str6 = CCString::create(\cf4 "String6"\cf0 );\
    \
    CCArray * array = CCArray::create();\
    array->addObject(str1);\
    array->addObject(str2);\
    array->addObject(str3);\
    array->addObject(str4);\
    array->addObject(str5);\
    array->addObject(str6);\
    \
    \
    array->removeLastObject();\
    \
    \cf5 for\cf0  (\cf5 int\cf0  i=\cf6 0\cf0 ; i<array->count(); i++)\
    \{\
        CCString* str=(CCString*)array->objectAtIndex(i);\
        CCLog(\cf4 "str:%s"\cf0 ,str->m_sString.c_str());\
    \}\
\}\
\
\cf2 //
\f1 \'d7\'d6\'b5\'e4
\f0 \cf0 \
\cf5 void\cf0  HelloWorld::testDictionary()\
\{\
    CCDictionary * dic = CCDictionary::create();\
    CCString* str1 = CCString::create(\cf4 "111"\cf0 );\
    CCString* str2 = CCString::create(\cf4 "222"\cf0 );\
    CCString* str3 = CCString::create(\cf4 "333"\cf0 );\
    CCInteger* str4 = CCInteger::create(\cf6 444\cf0 );\
    \
    dic->setObject(str1, \cf4 "k1"\cf0 );\
    dic->setObject(str2, \cf4 "k2"\cf0 );\
    dic->setObject(str3, \cf4 "k3"\cf0 );\
    dic->setObject(str4, \cf4 "k4"\cf0 );\
    \
    CCString * str11 = (CCString *)dic->objectForKey(\cf4 "k1"\cf0 );\
    CCLog(\cf4 "%s"\cf0 ,str11->getCString());\
    CCInteger * str22 = (CCInteger *)dic->objectForKey(\cf4 "k4"\cf0 );\
    CCLog(\cf4 "%d"\cf0 ,str22->getValue());\
    \
    \cf2 //dic->setObject(pass, "PWD");\cf0 \
\
 \cf2 //   CCDictElement * pElement = NULL;\cf0 \
\cf2 //    CCDICT_FOREACH(dic, pElement)\cf0 \
\cf2 //    \{\cf0 \
\cf2 //        CCString* str = (CCString*)pElement->getObject();\cf0 \
\cf2 //        \cf0 \
\cf2 //        CCLog(">>>  %s",str->getCString());\cf0 \
\cf2 //    \}\cf0 \
\
\}\
\
\cf2 //
\f1 \'b5\'b1\'bd\'f8\'c8\'eb\'b2\'bc\'be\'b0\'b2\'e3\'ca\'b1\'b5\'f7\'d3\'c3
\f0 \cf0 \
\cf5 void\cf0  HelloWorld:: onEnter()\
\{\
    CCLayer::onEnter();\
    CCLog(\cf4 "Enter"\cf0 );\
\}\
\
\cf2 //
\f1 \'b5\'b1\'c0\'eb\'bf\'aa\'b2\'bc\'be\'b0\'b2\'e3\'ca\'b1\'b5\'f7\'d3\'c3
\f0 \cf0 \
\cf5 void\cf0  HelloWorld:: onExit()\
\{\
    CCLayer::onExit();\
    CCLog(\cf4 "Exit"\cf0 );\
\}\
\
\cf5 void\cf0  HelloWorld::menuCloseCallback(CCObject* pSender)\
\{\
    \
    \cf5 int\cf0  s = ((CCMenuItemImage * )pSender)->getTag();\
    CCLog(\cf4 "%d"\cf0 ,s);\
    \
    CCTransitionFlipAngular * tr = CCTransitionFlipAngular::create(\cf6 1\cf0 , TestLayer::scene());\cf2 //
\f1 \'b4\'f8\'b6\'af\'bb\'ad\'b5\'c4\'cc\'f8\'d7\'aa\'a3\'ac\'d3\'c3\'b6\'af\'bb\'ad\'b0\'fc\'d7\'b0\'c1\'cb\'bd\'e7\'c3\'e6
\f0 \cf0 \
    CCDirector::sharedDirector()->replaceScene(tr);\
    \
\}\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardeftab770\pardirnatural

\f2\fs24 \cf0 \CocoaLigature1 \
\
\
\
\
\
\pard\tx770\pardeftab770\pardirnatural

\f1\fs32 \cf5 \CocoaLigature0 \'d3\'ce\'cf\'b7\'b5\'da\'b6\'fe\'cc\'ec
\f0 \
\
bool\cf0  \cf7 HelloWorld\cf0 ::init()\
\{\
    \cf5 if\cf0  ( !\cf7 CCLayer\cf0 ::\cf8 init\cf0 () )\
    \{\
        \cf5 return\cf0  \cf5 false\cf0 ;\
    \}\
    \cf7 CCSize\cf0  s = \cf7 CCDirector\cf0 ::\cf8 sharedDirector\cf0 ()->\cf8 getVisibleSize\cf0 ();\
\
    \cf2 //
\f1 \'cc\'ed\'bc\'d3\'be\'ab\'c1\'e9
\f0 \cf0 \
    \cf7 CCSprite\cf0  * sp = \cf7 CCSprite\cf0 ::\cf8 create\cf0 (\cf4 "bird.png"\cf0 );\
    sp->\cf8 setPosition\cf0 (\cf3 ccp\cf0 (s.width/\cf6 2\cf0 , s.\cf7 height\cf0 /\cf6 2\cf0 ));\
    sp->\cf8 setTag\cf0 (\cf6 10\cf0 );\
    \cf5 this\cf0 ->\cf8 addChild\cf0 (sp);\
    \
    \cf2 //
\f1 \'cc\'ed\'bc\'d3\'b0\'b4\'c5\'a5
\f0 \cf0 \
    \cf7 CCMenuItemFont\cf0  *font = \cf7 CCMenuItemFont\cf0  ::\cf8 create\cf0 (\cf4 "Click"\cf0 ,\cf5 this\cf0 ,\cf3 menu_selector\cf0 (\cf7 HelloWorld\cf0 ::\cf8 menuCloseCallback\cf0 ));\
    font->\cf8 setPosition\cf0 (\cf3 ccp\cf0 (\cf6 300\cf0 , \cf6 100\cf0 ));\
    \cf7 CCMenu\cf0  * menu = \cf7 CCMenu\cf0 ::\cf8 create\cf0 (font,\cf5 NULL\cf0 );\
    menu->\cf8 setPosition\cf0 (\cf7 CCPointZero\cf0 );\
    \cf5 this\cf0 ->\cf8 addChild\cf0 (menu);\
    \
   \
    \cf5 return\cf0  \cf5 true\cf0 ;\
\}\
\
\
\pard\tx770\pardeftab770\pardirnatural
\cf5 void\cf0  \cf7 HelloWorld\cf0 ::menuCloseCallback(\cf7 CCObject\cf0 * pSender)\
\{\
    \cf7 CCSprite\cf0  * sp = (\cf7 CCSprite\cf0  * )\cf5 this\cf0 ->\cf8 getChildByTag\cf0 (\cf6 10\cf0 );\
    \cf2 //move
\f1 \'d2\'c6\'b6\'af
\f0 \cf0 \
    \cf2 /*\
    CCMoveTo * move = CCMoveTo::create(3,ccp(600,300));\
    CCMoveBy * by = CCMoveBy::create(3, ccp(100, 100));\
    //sp->runAction(move);\
    //sp->runAction(by);\
    //sp->runAction(by->reverse());\
     */\cf0 \
    \
    \cf2 //scale
\f1 \'b7\'c5\'b4\'f3
\f0 \cf0 \
    \cf2 /*\
    CCScaleTo * scale = CCScaleTo::create(3, 2);\
    CCScaleBy * scaleby = CCScaleBy::create(3, 2);\
    CCActionInstant * action = (CCActionInstant *)scale->copy();//
\f1 \'bf\'bd\'b1\'b4\'b7\'bd\'b7\'a8
\f0 \
    sp->runAction(scaleby);\
    //sleep(4);\
    CCRect rect = sp->boundingBox();\
    CCLog("Size:%f %f",rect.size.width,rect.size.height);\
     */\cf0 \
    \
    \cf2 //rotate
\f1 \'d0\'fd\'d7\'aa
\f0 \cf0 \
    \cf2 /*\
    //CCRotateTo * rotate = CCRotateTo::create(3, 1000);//
\f1 \'d7\'aa
\f0 120
\f1 \'b6\'c8
\f0 \
    CCRotateBy * rotateby = CCRotateBy ::create(1, 1000);//
\f1 \'d0\'fd\'d7\'aa
\f0 1000
\f1 \'b6\'c8
\f0 \
    //sp->runAction(rotate);\
    sp->runAction(rotateby);\
     */\cf0 \
    \
    \cf2 //Jump
\f1 \'cc\'f8\'d4\'be
\f0 \cf0 \
    \cf2 /*\
    CCJumpTo * jump = CCJumpTo::create(3, ccp(240, 300), 50, 5);\
    //sp->runAction(jump);\
     */\cf0 \
    \
    \cf2 //Blink
\f1 \'c9\'c1\'cb\'b8
\f0 \cf0 \
    \cf2 /*\
    CCBlink * blink = CCBlink::create(3, 5);\
    sp->runAction(blink);\
    //CCActionInstant * action = (CCActionInstant *)blink->copy();//
\f1 \'bf\'bd\'b1\'b4\'b7\'bd\'b7\'a8
\f0 \
     */\cf0 \
    \
    \cf2 //
\f1 \'d2\'c6\'b3\'fd
\f0 \cf0 \
    \cf2 /*\
    sp->removeFromParent();\
     */\cf0 \
    \
    \cf2 //ccBezierConfig
\f1 \'b0\'b4\'c7\'fa\'cf\'df\'d2\'c6\'b6\'af
\f0 \cf0 \
    \cf2 /*\
    ccBezierConfig bezier;\
    bezier.controlPoint_1 = CCPointMake(0, 160);\
    bezier.controlPoint_2 = CCPointMake(300, 240);\
    bezier.endPosition = CCPointMake(300, 100);\
    CCBezierTo * bezierto = CCBezierTo::create(3, bezier);\
    sp->runAction(bezierto);\
     */\cf0 \
    \
    \cf2 //CCSequence
\f1 \'d7\'e9\'ba\'cf\'d2\'c6\'b6\'af
\f0 \cf0 \
    \cf2 /*\
    CCMoveTo * move = CCMoveTo::create(3, ccp(400,300));\
    CCScaleTo * scale = CCScaleTo::create(3, 2);\
    \
    //
\f1 \'d0\'f2\'c1\'d0\'b6\'af\'d7\'f7\'a3\'ac\'b9\'e3\'b7\'ba\'ca\'b9\'d3\'c3
\f0 \
    //CCSequence c\
    //sp->runAction(sequence);\
    \
    //
\f1 \'cd\'ac\'ca\'b1\'b1\'e4\'bb\'af
\f0 \
    CCSpawn * spawn = CCSpawn::create(move,scale,NULL);\
    sp->runAction(spawn);\
    */\cf0 \
    \
    \cf2 //
\f1 \'d3\'c0\'be\'c3\'d6\'b4\'d0\'d0\'b5\'c4\'b6\'af\'d7\'f7
\f0 \cf0 \
    \cf2 /*\
    CCRotateBy * ro = CCRotateBy ::create(3, 360);\
    CCRepeatForever * forever = CCRepeatForever::create(ro);\
    \
    CCMoveTo * move = CCMoveTo::create(3, ccp(400,300));\
    CCSequence * sequence = CCSequence::create(move,forever,NULL);//
\f1 \'b4\'ed\'ce\'f3\'a3\'ac
\f0 CCRepeatForever
\f1 \'b6\'d4\'cf\'f3\'b2\'bb\'c4\'dc\'b7\'c5\'d4\'da
\f0 CCSequence
\f1 \'d0\'f2\'c1\'d0\'b6\'af\'d7\'f7\'d6\'d0\'d4\'cb\'d0\'d0\'a3\'ac\'b1\'a8\'b4\'ed
\f0 override me\
    sp->runAction(sequence);\
    \
    //
\f1 \'c0\'b4\'bb\'d8\'d2\'bb\'d6\'b1\'b2\'bb\'b6\'cf\'b5\'c4\'d2\'c6\'b6\'af
\f0 \
    CCMoveBy * move = CCMoveBy::create(3, ccp(100,0));\
    CCSequence * sequence = CCSequence::create(move,move->reverse(),NULL);\
    CCRepeatForever * forever = CCRepeatForever::create(sequence);//CCRepeatForever
\f1 \'bf\'c9\'d2\'d4\'bc\'d3\'d4\'d8\'d0\'f2\'c1\'d0\'b6\'af\'d7\'f7
\f0 CCSequence\
    sp->runAction(forever);\
     */\cf0 \
    \
    \
    \cf2 //CCDelayTime
\f1 \'d1\'d3\'b3\'d9
\f0 \cf0 \
    \cf2 /*\
    CCMoveBy * move = CCMoveBy::create(3, ccp(100,0));\
    CCDelayTime * delay = CCDelayTime::create(3);\
    CCSequence * sequence = CCSequence::create(move,delay,move->reverse(),NULL);\
    CCRepeatForever * forever = CCRepeatForever::create(sequence);//CCRepeatForever
\f1 \'bf\'c9\'d2\'d4\'bc\'d3\'d4\'d8\'d0\'f2\'c1\'d0\'b6\'af\'d7\'f7
\f0 CCSequence\
    sp->runAction(forever);\
     */\cf0 \
    \
    \cf2 //
\f1 \'d4\'da\'b4\'b4\'bd\'a8\'d2\'bb\'b8\'f6\'be\'ab\'c1\'e9\'a3\'ac\'d2\'c6\'b6\'af\'d0\'c2\'bd\'a8\'b5\'c4\'be\'ab\'c1\'e9
\f0  
\f1 \'b8\'c4\'b1\'e4\'b6\'af\'d7\'f7\'d6\'b4\'d0\'d0\'b6\'d4\'cf\'f3
\f0 \cf0 \
    \cf2 /*\
    CCSprite * sp2 = CCSprite::create("bird2.png");\
    sp2->setPosition(ccp(200,200));\
    this->addChild(sp2);\
    CCMoveBy * moveby = CCMoveBy::create(2, ccp(100, 100));\
    CCTargetedAction * action = CCTargetedAction ::create(sp2, moveby);\
    sp->runAction(action);\
     */\cf0 \
   \
    \
    \cf2 //Progress
\f1 \'bd\'f8\'b6\'c8\'cc\'f5
\f0 \cf0 \
    \cf2 /*\
    CCProgressTo * progress = CCProgressTo::create(2, 100);//
\f1 \'b3\'d6\'d0\'f8\'ca\'b1\'bc\'e4\'a3\'ac\'b0\'d9\'b7\'d6\'b1\'c8
\f0 \
    //
\f1 \'bd\'f8\'b6\'c8\'bc\'c6\'ca\'b1\'c6\'f7
\f0 \
    CCProgressTimer * progressTimer = CCProgressTimer::create(CCSprite::create("grass.png"));\
    progressTimer->setType(kCCProgressTimerTypeBar);\
    //kCCProgressTimerTypeRadial,
\f1 \'c9\'c8\'d0\'ce
\f0 \
    //kCCProgressTimerTypeBar,
\f1 \'cc\'f5
\f0 \
\
    progressTimer->setPosition(ccp(240,240));\
    progressTimer->setMidpoint(ccp(0, 1));\
    this->addChild(progressTimer);\
    CCSequence* sequence = CCSequence::create(progress,CCDelayTime::create(1),NULL);\
    progressTimer->runAction(CCRepeatForever::create(sequence));\
     */\cf0 \
    \
\}\
\
\
\
\cf3 #include \cf4 "TestCallBack.h"\cf3 \
USING_NS_CC\cf0 ;\
\
\pard\tx770\pardeftab770\pardirnatural
\cf7 CCScene\cf0 * \cf7 TestCall\cf0 ::scene()\
\{\
    \cf7 CCScene\cf0  *scene = \cf7 CCScene\cf0 ::\cf8 create\cf0 ();\
    \cf2 // 'layer' is an autorelease object\cf0 \
    \cf7 TestCall\cf0  *layer = \cf7 TestCall\cf0 ::\cf8 create\cf0 ();\
    \cf2 // add layer as a child to scene\cf0 \
    scene->\cf8 addChild\cf0 (layer);\
    \cf2 // return the scene\cf0 \
    \cf5 return\cf0  scene;\
\}\
\
\pard\tx770\pardeftab770\pardirnatural
\cf5 bool\cf0  \cf7 TestCall\cf0 ::init()\
\{\
    \cf5 if\cf0  ( !\cf7 CCLayer\cf0 ::\cf8 init\cf0 ())\
    \{\
        \cf5 return\cf0  \cf5 false\cf0 ;\
    \}\
    \
    \cf2 //CCSize s = CCDirector::sharedDirector()->getVisibleSize();\cf0 \
    \cf2 //CCLog("%f %f",s.width,s.height);\cf0 \
    \
    \cf7 CCSprite\cf0  * sp = \cf7 CCSprite\cf0 ::\cf8 create\cf0 (\cf4 "bird.png"\cf0 );\
    sp->\cf8 setPosition\cf0 (\cf3 ccp\cf0 (\cf6 200\cf0 , \cf6 200\cf0 ));\
    sp->\cf8 setTag\cf0 (\cf6 20\cf0 );\
    \cf5 this\cf0 ->\cf8 addChild\cf0 (sp);\
    \
    \cf2 //
\f1 \'cb\'b2\'ca\'b1\'b6\'af\'d7\'f7
\f0 CCCallFunc\cf0 \
    \cf2 /*\
    CCMoveTo * moveTo = CCMoveTo::create(3, ccp(300, 300));\
    CCSpeed * speed = CCSpeed::create(moveTo, 0.1);\
    sp->runAction(speed);\
\
    //CCActionIntant\
    //
\f1 \'cb\'b2\'ca\'b1\'b6\'af\'d7\'f7\'b5\'c4\'d2\'e2\'cb\'bc\'be\'cd\'ca\'c7\'b6\'af\'d7\'f7\'d6\'b4\'d0\'d0\'b2\'bb\'d0\'e8\'d2\'aa\'ca\'b1\'bc\'e4
\f0 ,
\f1 \'c2\'ed\'c9\'cf\'be\'cd\'b4\'ef\'b5\'bd\'c9\'e8\'b6\'a8\'b5\'c4\'d7\'b4\'cc\'ac
\f0 ,
\f1 \'cb\'b2\'ca\'b1\'b6\'af\'d7\'f7\'b5\'c4\'d7\'d3\'c0\'e0
\f0 \
    //CCCallFunc 
\f1 \'d6\'b4\'d0\'d0\'bb\'d8\'b5\'f7\'ba\'af\'ca\'fd
\f0 \
    //
\f1 \'cb\'b2\'ca\'b1\'b6\'af\'d7\'f7\'d3\'c3\'b5\'c4\'b1\'c8\'bd\'cf\'b6\'e0\'b5\'c4\'be\'cd\'ca\'c7
\f0  CCCallFunc 
\f1 \'bc\'d2\'d7\'e5
\f0 \
    //CCCallFunc 
\f1 \'ca\'c7\'d6\'b4\'d0\'d0\'b6\'d4\'d3\'a6\'b5\'c4\'bb\'d8\'b5\'f7\'ba\'af\'ca\'fd
\f0 ,
\f1 \'c6\'e4\'d6\'d0\'bb\'d8\'b5\'f7\'ba\'af\'ca\'fd\'b2\'bb\'bf\'c9\'b4\'f8\'b2\'ce\'ca\'fd\'a1\'a3
\f0 \
    //CCCallFuncN 
\f1 \'d2\'b2\'ca\'c7\'d6\'b4\'d0\'d0\'b6\'d4\'d3\'a6\'b5\'c4\'bb\'d8\'b5\'f7\'ba\'af\'ca\'fd
\f0 ,
\f1 \'c6\'e4\'d6\'d0\'bb\'d8\'b5\'f7\'ba\'af\'ca\'fd\'b4\'f8\'d2\'bb\'b8\'f6\'b2\'ce\'ca\'fd\'a1\'a3
\f0 \
    //CCCallFuncND 
\f1 \'d2\'b2\'ca\'c7\'d6\'b4\'d0\'d0\'b6\'d4\'d3\'a6\'b5\'c4\'bb\'d8\'b5\'f7\'ba\'af\'ca\'fd
\f0 ,
\f1 \'c6\'e4\'d6\'d0\'bb\'d8\'b5\'f7\'ba\'af\'ca\'fd\'bf\'c9\'b4\'f8\'c1\'bd\'b8\'f6\'b2\'ce\'ca\'fd\'a1\'a3
\f0 \
    CCCallFunc * func = CCCallFunc::create(this, callfunc_selector(TestCall::callback1));//callfunc_selector(
\f1 \'b1\'d8\'d0\'eb\'bc\'d3\'d7\'f7\'d3\'c3\'d3\'f2\'a3\'ac\'cb\'fb\'bf\'c9\'d2\'d4\'b5\'f7\'d3\'c3\'b3\'fd
\f0 this
\f1 \'b5\'c4\'c6\'e4\'cb\'fb\'b7\'bd\'b7\'a8
\f0 )\
    CCCallFuncN * funcN = CCCallFuncN::create(this, callfuncN_selector(TestCall::callback2));\
    int a = 5;\
    CCCallFuncND * funcND = CCCallFuncND ::create(this, callfuncND_selector(TestCall::callback3), (void *)a);\
    CCSequence * sequence = CCSequence::create(moveTo,func,funcN,funcND,NULL);\
    sp->runAction(sequence);\
    */\cf0 \
    \
    \cf2 //CCSpeed 
\f1 \'bf\'c9\'b5\'f7\'d5\'fb\'b6\'af\'d7\'f7
\f0    
\f1 \'b8\'f8\'b6\'af\'d7\'f7\'c9\'e8\'d6\'c3\'cb\'d9\'b6\'c8
\f0 \cf0 \
    \cf2 /*\
    //CCSpeed 
\f1 \'ca\'c7
\f0  CCAction 
\f1 \'b5\'c4\'d7\'d3\'c0\'e0
\f0 ,
\f1 \'cb\'f9\'d2\'d4\'cb\'fc\'b2\'bb\'c4\'dc\'d7\'f7\'ce\'aa\'c8\'ce\'ba\'ce\'d7\'e9\'ba\'cf\'b6\'af\'d7\'f7\'d6\'d0\'b5\'c4\'b5\'a5\'b6\'c0\'d4\'aa\'cb\'d8
\f0 , 
\f1 \'cb\'fc\'d2\'b2\'c3\'bb\'d3\'d0\'b7\'b4\'b6\'af\'d7\'f7
\f0 ,
\f1 \'cb\'fc\'d6\'bb\'c4\'dc\'b1\'bb
\f0  CCNode 
\f1 \'b6\'d4\'cf\'f3\'d6\'b4\'d0\'d0\'a1\'a3
\f0 \
    CCMoveTo * moveTo = CCMoveTo::create(3, ccp(300, 300));\
    CCSpeed * speed = CCSpeed::create(moveTo, 1);//
\f1 \'cb\'fc\'ca\'c7\'b8\'f8\'b6\'af\'d7\'f7\'c9\'e8\'d6\'c3\'cb\'d9\'b6\'c8
\f0 ,
\f1 \'b4\'f3\'d3\'da
\f0  1,
\f1 \'cb\'d9\'b6\'c8\'bc\'d3\'bf\'ec
\f0 ,
\f1 \'d0\'a1\'d3\'da
\f0  1,
\f1 \'cb\'d9\'b6\'c8\'bc\'f5\'c2\'fd
\f0 ,
\f1 \'b5\'c8\'d3\'da
\f0  1 
\f1 \'cb\'d9\'b6\'c8\'b1\'a3\'b3\'d6\'b2\'bb\'b1\'e4\'a1\'a3
\f0 \
    sp->runAction(speed);\
    */\cf0 \
    \
    \cf2 //CCFollow 
\f1 \'b8\'fa\'cb\'e6\'b6\'af\'d7\'f7
\f0 \cf0 \
    \cf2 /*\
    //CCFollow 
\f1 \'cd\'ac\'d1\'f9\'ca\'c7
\f0  CCAction 
\f1 \'b5\'c4\'d7\'d3\'c0\'e0\'a1\'a3
\f0 \
    CCFollow *follow = CCFollow::create(sp);\
    //
\f1 \'ba\'dc\'b6\'e0\'cd\'ac\'d1\'a7\'bf\'c9\'c4\'dc\'bb\'e1\'d5\'e2\'d1\'f9\'c8\'cf\'ce\'aa
\f0 ,
\f1 \'d5\'e2\'b8\'f6\'bf\'c9\'d2\'d4\'c9\'e8\'d6\'c3\'d2\'bb\'b8\'f6\'be\'ab\'c1\'e9\'b8\'fa\'cb\'e6\'d2\'bb\'b8\'f6\'be\'ab\'c1\'e9
\f0 ,
\f1 \'b5\'ab\'ca\'c7\'ca\'b5
\f0 \
    //
\f1 \'bc\'ca\'c9\'cf\'b2\'bb\'ca\'c7\'d5\'e2\'d1\'f9\'b5\'c4
\f0 ,CCFollow 
\f1 \'be\'ad\'b3\'a3\'d3\'c3\'c0\'b4\'c9\'e8\'d6\'c3
\f0  layer 
\f1 \'b8\'fa\'cb\'e6
\f0  sprite,
\f1 \'bf\'c9\'d2\'d4\'ca\'b5\'cf\'d6\'c0\'e0\'cb\'c6\'c9\'e3\'cf\'f1
\f0  
\f1 \'bb\'fa\'b8\'fa\'c5\'c4\'b5\'c4\'d0\'a7\'b9\'fb\'a1\'a3
\f0 \
    this->runAction(CCFollow::create(sp));\
    */\cf0 \
    \cf8 CCDirector\cf0 ::sharedDirector()->getActionManager()->pauseTarget(sp);\
    CCLog(\cf4 "<<<<<<"\cf0 );\
    \
    \cf7 CCMoveTo\cf0  * \cf7 moveTo\cf0  = \cf8 CCMoveTo\cf0 ::create(\cf6 3\cf0 , ccp(\cf6 300\cf0 , \cf6 300\cf0 ));\
    \cf8 CCSpeed\cf0  * speed = CCSpeed::create(moveTo, \cf6 1\cf0 );\
    sp->runAction(speed);\
    \cf2 //sp->stopAllActions();//
\f1 \'cf\'c2\'b4\'ce\'b4\'d3\'d7\'ee\'bf\'aa\'ca\'bc\'d6\'b4\'d0\'d0\'a3\'ac\'b2\'bb\'c4\'dc\'b4\'d3\'c9\'cf\'b4\'ce\'d4\'dd\'cd\'a3\'b5\'c4\'b5\'d8\'b7\'bd\'d6\'b4\'d0\'d0
\f0 ;\cf0 \
    \
    \cf8 CCDirector\cf0 ::\cf8 sharedDirector\cf0 ()->\cf8 getActionManager\cf0 ()->pauseTarget(sp);\
    CCLog(\cf4 "<<<<<<"\cf0 );\
    \cf2 //CCDirector::sharedDirector()->getActionManager()->resumeTarget(sp);\cf0 \
    \
    \cf5 return\cf0  \cf5 true\cf0 ;\
\}\
\
\cf5 void\cf0  TestCall::callback1 ()\
\{\
    CCLog(\cf4 "callback1"\cf0 );\
\}\
\cf5 void\cf0  TestCall::callback2(CCNode * sender)\
\{\
    \cf7 CCLog\cf0 (\cf4 "callback2"\cf0 );\
    \cf8 CCSprite\cf0  * sp = (\cf8 CCSprite\cf0  *)sender;\
    CCLog(\cf4 "Tag = %d "\cf0 ,sp->getTag());\
\}\
\cf5 void\cf0  TestCall::callback3(CCNode * sender,\cf5 void\cf0  * a)\
\{\
    \cf5 int\cf0  m = (\cf5 int\cf0 ) a;\
    \cf8 CCLog\cf0 (\cf4 "callback3"\cf0 );\
    CCLog(\cf4 "m = %d"\cf0 ,m);\
\}\
\
\
\
\
//////////////
\f1 \'b5\'da\'c8\'fd\'cc\'ec
\f0 \
\cf3 #include \cf4 "HelloWorldScene.h"\cf3 \
\cf0 \
\cf3 USING_NS_CC\cf0 ;\
\
\
\cf2 // on "init" you need to initialize your instance\cf0 \
\cf5 bool\cf0  \cf7 HelloWorld\cf0 ::init()\
\{\
    \cf2 //////////////////////////////\cf0 \
    \cf2 // 1. super init first\cf0 \
    \cf5 if\cf0  ( !\cf7 CCLayer\cf0 ::\cf8 init\cf0 () )\
    \{\
        \cf5 return\cf0  \cf5 false\cf0 ;\
    \}\
    \
    \cf7 CCSize\cf0  s = \cf7 CCDirector\cf0 ::\cf8 sharedDirector\cf0 ()->\cf8 getVisibleSize\cf0 ();\
    \
    \cf2 //CCTexture2D 
\f1 \'b5\'c4\'c8\'dd\'c6\'f7
\f0 ,
\f1 \'ca\'c7\'c4\'da\'b4\'e6\'b3\'d8
\f0 \cf0 \
    \cf2 /*\
    //CCTexture2D 
\f1 \'b5\'c4\'c8\'dd\'c6\'f7
\f0 ,
\f1 \'ca\'c7\'c4\'da\'b4\'e6\'b3\'d8
\f0 ,
\f1 \'d3\'c3\'c0\'b4\'bb\'ba\'b4\'e6
\f0  CCTexture2D 
\f1 \'b6\'d4\'cf\'f3\'b5\'c4
\f0 , 
\f1 \'cb\'fc\'c4\'da\'b2\'bf\'d3\'d0\'d2\'bb\'b8\'f6\'d7\'d6\'b5\'e4
\f0  CCMutableDictionary m_pTextures,key 
\f1 \'ce\'aa\'cd\'bc\'c6\'ac\'b5\'c4\'c3\'fb\'b3\'c6
\f0 ,
\f1 \'d6\'b5\'ca\'c7
\f0  CCTexture2D
\f1 \'a1\'a3\'b5\'b1\'b5\'f7\'d3\'c3\'cb\'fc\'b5\'c4
\f0  addImage 
\f1 \'ba\'af\'ca\'fd\'cc\'ed\'bc\'d3\'cd\'bc\'c6\'ac\'ca\'b1
\f0 ,
\f1 \'bb\'e1\'cf\'c8\'b8\'f9\'be\'dd\'cd\'bc\'c6\'ac\'c3\'fb\'b3\'c6\'c8\'a5\'c4\'da\'b4\'e6\'d6\'d0\'b2\'e9\'d5\'d2\'ca\'c7\'b7\'f1\'d2\'d1\'b4\'e6\'d4\'da
\f0 ,
\f1 \'ca\'c7\'d4\'f2\'d6\'b1\'bd\'d3\'c8\'a1\'b3\'f6\'b7\'b5\'bb\'d8\'a1\'a3
\f0 \
    CCTexture2D * textture = CCTextureCache::sharedTextureCache()->addImage("s_hurt.png");//
\f1 \'c8\'e7\'b9\'fb\'d0\'e8\'d2\'aa\'b6\'e0\'b4\'ce\'bc\'d3\'d4\'d8\'d2\'bb\'d5\'c5\'cd\'bc\'c6\'ac\'b5\'c4\'ca\'b1\'ba\'f2
\f0 ,
\f1 \'bf\'c9\'d2\'d4\'cf\'c8\'b0\'d1\'cd\'bc\'c6\'ac\'bc\'d3\'d4\'d8\'b5\'bd
\f0  CCTextureCache 
\f1 \'d6\'d0
\f0 ,
\f1 \'d5\'e2\'d1\'f9\'ca\'b9\'d3\'c3\'cd\'bc\'c6\'ac\'b5\'c4\'ca\'b1\'ba\'f2\'cb\'d9\'b6\'c8\'be\'cd\'bb\'e1\'ba\'dc\'bf\'ec\'c1\'cb
\f0 \
    CCSprite * sp = CCSprite::createWithTexture(textture);\
    sp->setPosition(ccp(s.width/2, s.height/2));\
    this->addChild(sp);\
    */\cf0 \
    \
    \cf2 //testSpriteBatchNode();\cf0 \
    \
    \cf8 testSpriteFrame\cf0 ();\
 \
    \cf5 return\cf0  \cf5 true\cf0 ;\
\}\
\
\cf2 //
\f1 \'ca\'b5\'cf\'d6\'d6\'a1\'b6\'af\'bb\'ad
\f0 \cf0 \
\cf5 void\cf0  \cf7 HelloWorld\cf0 ::testSpriteFrame()\
\{\
    \cf7 CCSpriteFrameCache\cf0  * cache = \cf7 CCSpriteFrameCache\cf0 ::\cf8 sharedSpriteFrameCache\cf0 ();\
    \
    \cf2 //cache -> addSpriteFramesWithFile("Zombie_default.plist");\cf0 \
    cache -> \cf8 addSpriteFramesWithFile\cf0 (\cf4 "123.plist"\cf0 );\
    \cf7 CCSprite\cf0  * sp = \cf7 CCSprite\cf0 ::\cf8 createWithSpriteFrameName\cf0 (\cf4 "s_1.png"\cf0 );\
    \
    sp->\cf8 setPosition\cf0 (\cf3 ccp\cf0 (\cf6 700\cf0 ,\cf6 200\cf0 ));\
    \
    \cf5 this\cf0 ->\cf8 addChild\cf0 (sp);\
    \
    \
    \cf2 //
\f1 \'bd\'ab\'ce\'c4\'bc\'fe\'d6\'d0\'b5\'c4\'d7\'f7\'ce\'aa\'d2\'bb\'b8\'f6\'d7\'d6\'b5\'e4\'b6\'c1\'c8\'a1\'b3\'f6\'c0\'b4
\f0 \cf0 \
    \cf7 CCDictionary\cf0  * dic = \cf7 CCDictionary\cf0 ::\cf8 createWithContentsOfFile\cf0 (\cf4 "123.plist"\cf0 );\
    dic->\cf8 retain\cf0 ();\
    \cf2 //
\f1 \'bb\'f1\'c8\'a1\'cb\'f9\'d3\'d0\'b5\'c4\'be\'ab\'c1\'e9\'d6\'a1
\f0 \cf0 \
    \cf7 CCDictionary\cf0  * frameDic = (\cf7 CCDictionary\cf0  * )dic->\cf8 objectForKey\cf0 (\cf4 "frames"\cf0 );\
    frameDic->\cf8 retain\cf0 ();\
    \
    \cf2 //
\f1 \'bb\'f1\'c8\'a1\'cb\'f9\'d3\'d0\'be\'ab\'c1\'e9\'d6\'a1\'b5\'c4\'ca\'fd\'c1\'bf
\f0 \cf0 \
    \cf5 int\cf0  num = frameDic->\cf8 allKeys\cf0 ()->\cf8 count\cf0 ();\
    \cf2 //
\f1 \'b4\'b4\'bd\'a8\'d2\'bb\'b8\'f6\'ca\'fd\'d7\'e9
\f0 \cf0 \
    \cf7 CCArray\cf0  * allFrames = \cf7 CCArray\cf0 ::\cf8 createWithCapacity\cf0 (\cf6 20\cf0 );\
    \cf2 //for
\f1 \'d1\'ad\'bb\'b7\'a3\'ac\'b0\'d1\'d6\'a1\'b7\'c5\'c8\'eb\'ca\'fd\'d7\'e9\'d6\'d0
\f0 \cf0 \
    \cf5 for\cf0  (\cf5 int\cf0  i = \cf6 0\cf0 ; i<num; ++i)\
    \{\
        \cf5 char\cf0  frame[\cf6 20\cf0 ];\
        \cf9 sprintf\cf0 (frame, \cf4 "s_%d.png"\cf0 ,i+\cf6 1\cf0 );\
         \cf7 CCSpriteFrame\cf0 * frameName = \cf7 CCSpriteFrameCache\cf0 ::\cf8 sharedSpriteFrameCache\cf0 ()->\cf8 spriteFrameByName\cf0 (frame);\
\
        allFrames -> \cf8 addObject\cf0 (frameName);\
    \}\
    \
    \cf2 //
\f1 \'b8\'f9\'be\'dd\'be\'ab\'c1\'e9\'d6\'a1\'ca\'fd\'d7\'e9\'b4\'b4\'bd\'a8\'b6\'af\'bb\'ad
\f0 \cf0 \
    \cf7 CCAnimation\cf0  * animation = \cf7 CCAnimation\cf0 ::\cf8 createWithSpriteFrames\cf0 (allFrames,\cf6 0.1\cf0 );\
    \cf7 CCAnimate\cf0  * animate = \cf7 CCAnimate\cf0 ::\cf8 create\cf0 (animation);\
    \cf7 CCRepeatForever\cf0  * forever = \cf7 CCRepeatForever\cf0 ::\cf8 create\cf0 (animate);\
    \
    \cf2 //CCMoveTo * move = CCMoveTo::create(2,ccp(-20, 200));\cf0 \
    sp->\cf8 runAction\cf0 (forever);\
    \cf2 //sp->runAction(move);\cf0 \
   \
\}\
\
\cf2 //n
\f1 \'b8\'f6\'cd\'bc\'c6\'ac\'cb\'e6\'bb\'fa
\f0 \cf0 \
\cf5 void\cf0  \cf7 HelloWorld\cf0 ::testSpriteBatchNode()\
\{\
    \
    \cf7 CCSpriteBatchNode\cf0  * batchNode = \cf7 CCSpriteBatchNode\cf0 ::\cf8 create\cf0 (\cf4 "Icon-144.png"\cf0 );\
    batchNode->\cf8 setPosition\cf0 (\cf7 CCPointZero\cf0 );\
    \cf5 this\cf0 ->\cf8 addChild\cf0 (batchNode);\
    \
    \
    \cf5 for\cf0  (\cf5 int\cf0  n = \cf6 0\cf0 ; n<\cf6 10\cf0 ; ++n)\
    \{\
        \cf5 int\cf0  x = \cf9 arc4random\cf0 ()%\cf6 960\cf0 ; \cf2 //
\f1 \'bb\'f1\'c8\'a1\'cb\'e6\'bb\'fa\'ca\'fd
\f0 \cf0 \
        \cf5 int\cf0  y = \cf9 arc4random\cf0 ()%\cf6 640\cf0 ;\
        \
\cf2 //        CCSprite * sp = CCSprite::create("Icon-144.png");\cf0 \
\cf2 //        \cf0 \
\cf2 //        sp->setPosition(ccp(x,y));\cf0 \
\cf2 //        \cf0 \
\cf2 //         addChild(sp);\cf0 \
        \
        \cf7 CCSprite\cf0  * sp = \cf7 CCSprite\cf0 ::\cf8 createWithTexture\cf0 (batchNode->\cf8 getTexture\cf0 ());\
        sp->\cf8 setPosition\cf0 (\cf3 ccp\cf0 (x,y));\
        batchNode->\cf8 addChild\cf0 (sp);\
        \
       \
    \}\
\}\
\
\
\pard\tx770\pardeftab770\pardirnatural

\f1 \cf0 /////////////////////////////////////////////////////////\'b5\'da\'cb\'c4\'cc\'ec\
\pard\tx770\pardeftab770\pardirnatural

\f0 \cf3 #include \cf4 "HelloWorldScene.h"\cf3 \
\cf0 \
\pard\tx770\pardeftab770\pardirnatural
\cf7 USING_NS_CC\cf0 ;\
\
\pard\tx770\pardeftab770\pardirnatural
\cf2 //
\f1 \'d2\'f4\'c0\'d6
\f0 \cf0 \
\cf3 #include \cf4 "SimpleAudioEngine.h"\cf3 \
\cf5 using\cf0  \cf5 namespace\cf0  \cf7 CocosDenshion\cf0 ;\
\
\pard\tx770\pardeftab770\pardirnatural
\cf7 CCScene\cf0 * \cf7 HelloWorld\cf0 ::scene()\
\{\
    \cf2 // 'scene' is an autorelease object\cf0 \
    \cf7 CCScene\cf0  *scene = \cf7 CCScene\cf0 ::\cf8 create\cf0 ();\
    \
    \cf2 // 'layer' is an autorelease object\cf0 \
    \cf7 HelloWorld\cf0  *layer = \cf7 HelloWorld\cf0 ::\cf8 create\cf0 ();\
\
    \cf2 // add layer as a child to scene\cf0 \
    scene->\cf8 addChild\cf0 (layer);\
\
    \cf2 // return the scene\cf0 \
    \cf5 return\cf0  scene;\
\}\
\
\pard\tx770\pardeftab770\pardirnatural
\cf5 bool\cf0  \cf7 HelloWorld\cf0 ::init()\
\{\
    \cf2 //////////////////////////////\cf0 \
    \cf2 // 1. super init first\cf0 \
    \cf5 if\cf0  ( !\cf7 CCLayer\cf0 ::\cf8 init\cf0 () )\
    \{\
        \cf5 return\cf0  \cf5 false\cf0 ;\
    \}\
    \
    \cf2 // CCSize visibleSize = CCDirector::sharedDirector()->getVisibleSize();\cf0 \
    \cf8 testSlider\cf0 ();\
    \
    \cf2 //
\f1 \'b2\'a5\'b7\'c5\'b1\'b3\'be\'b0\'d2\'f4\'c0\'d6
\f0 \cf0 \
    \cf7 SimpleAudioEngine\cf0 ::\cf8 sharedEngine\cf0 ()->\cf8 playBackgroundMusic\cf0 (\cf4 "background.mp3"\cf0 , \cf5 true\cf0 );\cf2 //
\f1 \'b5\'da\'b6\'fe\'b8\'f6\'b2\'ce\'ca\'fd\'a3\'ba\'ca\'c7\'b7\'f1\'d6\'d8\'b8\'b4\'b2\'a5\'b7\'c5
\f0 \cf0 \
    \
    \cf8 testCColorPicker\cf0 ();\
    \
    \
    testSwitch();\
    \
    \
    \cf8 testCCControlButton\cf0 ();\
    \
    \
    \cf8 testCCEditBox\cf0 ();\
    \cf5 return\cf0  \cf5 true\cf0 ;\
\}\
\
\cf2 //
\f1 \'b2\'e2\'ca\'d4\'ce\'c4\'b1\'be\'bf\'f2
\f0 CCEditBox\cf0 \
\cf5 void\cf0  \cf7 HelloWorld\cf0 ::testCCEditBox()\
\{\
    \cf7 CCScale9Sprite\cf0  * sp = \cf7 CCScale9Sprite\cf0 ::\cf8 create\cf0 (\cf4 "textField.png"\cf0 );\
    sp->\cf8 setPreferredSize\cf0 (\cf7 CCSizeMake\cf0 (\cf6 500\cf0 , \cf6 80\cf0 ));\
    sp->\cf8 setAnchorPoint\cf0 (\cf7 ccp\cf0 (\cf6 0.5\cf0 , \cf6 0.5\cf0 ));\
    \cf7 CCEditBox\cf0  * box = \cf7 CCEditBox\cf0 ::\cf8 create\cf0 (\cf7 CCSizeMake\cf0 (\cf6 500\cf0 , \cf6 80\cf0 ), sp);\
    box->\cf8 setPlaceHolder\cf0 (\cf4 "
\f1 \'c7\'eb\'ca\'e4\'c8\'eb\'c3\'fb\'d7\'d6
\f0 "\cf0 );\
    box->\cf8 setFontColor\cf0 (\cf8 ccc3\cf0 (\cf6 255\cf0 , \cf6 0\cf0 , \cf6 255\cf0 ));\
    box->\cf8 setPosition\cf0 (\cf7 ccp\cf0 (\cf6 500\cf0 , \cf6 500\cf0 ));\
    \cf2 //
\f1 \'c9\'e8\'d6\'c3\'ca\'e4\'c8\'eb\'c4\'a3\'ca\'bd
\f0 \cf0 \
    box->\cf8 setInputMode\cf0 (\cf8 kEditBoxInputModeAny\cf0 );\
    \cf2 /*\
    // kEditBoxInputModeAny: 
\f1 \'bf\'aa\'c6\'f4\'c8\'ce\'ba\'ce\'ce\'c4\'b1\'be\'b5\'c4\'ca\'e4\'c8\'eb\'bc\'fc\'c5\'cc
\f0 ,
\f1 \'b0\'fc\'c0\'a8\'bb\'bb\'d0\'d0
\f0 \
    // kEditBoxInputModeEmailAddr: 
\f1 \'bf\'aa\'c6\'f4
\f0  
\f1 \'d3\'ca\'bc\'fe\'b5\'d8\'d6\'b7
\f0  
\f1 \'ca\'e4\'c8\'eb\'c0\'e0\'d0\'cd\'bc\'fc\'c5\'cc
\f0 \
    // kEditBoxInputModeNumeric: 
\f1 \'bf\'aa\'c6\'f4
\f0  
\f1 \'ca\'fd\'d7\'d6\'b7\'fb\'ba\'c5
\f0  
\f1 \'ca\'e4\'c8\'eb\'c0\'e0\'d0\'cd\'bc\'fc\'c5\'cc
\f0 \
    // kEditBoxInputModePhoneNumber: 
\f1 \'bf\'aa\'c6\'f4
\f0  
\f1 \'b5\'e7\'bb\'b0\'ba\'c5\'c2\'eb
\f0  
\f1 \'ca\'e4\'c8\'eb\'c0\'e0\'d0\'cd\'bc\'fc\'c5\'cc
\f0 \
    // kEditBoxInputModeUrl:
\f1 \'bf\'aa\'c6\'f4
\f0  URL 
\f1 \'ca\'e4\'c8\'eb\'c0\'e0\'d0\'cd\'bc\'fc\'c5\'cc
\f0 \
    // kEditBoxInputModeDecimal: 
\f1 \'bf\'aa\'c6\'f4
\f0  
\f1 \'ca\'fd\'d7\'d6
\f0  
\f1 \'ca\'e4\'c8\'eb\'c0\'e0\'d0\'cd\'bc\'fc\'c5\'cc
\f0 ,
\f1 \'d4\'ca\'d0\'ed\'d0\'a1\'ca\'fd\'b5\'e3
\f0 \
    // kEditBoxInputModeSingleLine: 
\f1 \'bf\'aa\'c6\'f4\'c8\'ce\'ba\'ce\'ce\'c4\'b1\'be\'b5\'c4\'ca\'e4\'c8\'eb\'bc\'fc\'c5\'cc
\f0 ,
\f1 \'b2\'bb\'b0\'fc\'c0\'a8\'bb\'bb\'d0\'d0
\f0 \
    */\cf0 \
    \
    \cf2 //
\f1 \'c9\'e8\'d6\'c3\'ca\'e4\'c8\'eb\'c0\'e0\'d0\'cd
\f0 \cf0 \
    box->\cf8 setInputFlag\cf0 (\cf8 kEditBoxInputFlagPassword\cf0 );\cf2 //
\f1 \'d2\'fe\'b2\'d8\'ca\'e4\'c8\'eb\'c4\'da\'c8\'dd
\f0 \cf0 \
    \cf2 /*\
     // kEditBoxInputFlagPassword: 
\f1 \'c3\'dc\'c2\'eb\'d0\'ce\'ca\'bd\'ca\'e4\'c8\'eb
\f0 \
     // kEditBoxInputFlagSensitive: 
\f1 \'c3\'f4\'b8\'d0\'ca\'fd\'be\'dd\'ca\'e4\'c8\'eb\'a1\'a2\'b4\'e6\'b4\'a2\'ca\'e4\'c8\'eb\'b7\'bd\'b0\'b8\'c7\'d2\'d4\'a4\'b2\'e2\'d7\'d4
\f0  
\f1 \'b6\'af\'cd\'ea\'b3\'c9
\f0 \
     // kEditBoxInputFlagInitialCapsWord: 
\f1 \'c3\'bf\'b8\'f6\'b5\'a5\'b4\'ca\'ca\'d7\'d7\'d6\'c4\'b8\'b4\'f3\'d0\'b4
\f0 ,
\f1 \'b2\'a2\'c7\'d2\'b0\'e9\'d3\'d0
\f2 \uc0\u56319 \u56320 
\f1 \'ca\'be
\f0  \
     // kEditBoxInputFlagInitialCapsSentence: 
\f1 \'b5\'da\'d2\'bb\'be\'e4\'ca\'d7\'d7\'d6\'c4\'b8\'b4\'f3\'d0\'b4
\f0 ,
\f1 \'b2\'a2\'c7\'d2\'b0\'e9\'d3\'d0
\f2 \uc0\u56319 \u56320 
\f1 \'ca\'be
\f0  \
     // kEditBoxInputFlagInitialCapsAllCharacters: 
\f1 \'cb\'f9\'d3\'d0\'d7\'d6\'b7\'fb\'d7\'d4\'b6\'af\'b4\'f3\'d0\'b4
\f0 \
     // \
     */\cf0 \
    \
    \cf2 //
\f1 \'d7\'ee\'b4\'f3\'ca\'e4\'c8\'eb\'ce\'c4\'b1\'be\'b3\'a4\'b6\'c8
\f0 \cf0 \
    box->\cf8 setMaxLength\cf0 (\cf6 10\cf0 );\
    \
    \cf2 //
\f1 \'c9\'e8\'d6\'c3\'b7\'b5\'bb\'d8\'c0\'e0\'d0\'cd
\f0 \cf0 \
    box->\cf8 setReturnType\cf0 (\cf8 kKeyboardReturnTypeDone\cf0 );\
    \cf2 /*\
     // kKeyboardReturnTypeDefault: 
\f1 \'c4\'ac\'c8\'cf\'ca\'b9\'d3\'c3\'bc\'fc\'c5\'cc
\f0  return 
\f1 \'c0\'e0\'d0\'cd
\f0 \
     // kKeyboardReturnTypeDone: 
\f1 \'c4\'ac\'c8\'cf\'ca\'b9\'d3\'c3\'bc\'fc\'c5\'cc
\f0  return 
\f1 \'c0\'e0\'d0\'cd\'ce\'aa
\f0 \'93Done\'94
\f1 \'d7\'d6\'d1\'f9
\f0 \
     67\
     www.neworigin.net\
     // kKeyboardReturnTypeSend: 
\f1 \'c4\'ac\'c8\'cf\'ca\'b9\'d3\'c3\'bc\'fc\'c5\'cc
\f0  return 
\f1 \'c0\'e0\'d0\'cd\'ce\'aa
\f0 \'93Send\'94
\f1 \'d7\'d6\'d1\'f9
\f0 \
     // kKeyboardReturnTypeSearch: 
\f1 \'c4\'ac\'c8\'cf\'ca\'b9\'d3\'c3\'bc\'fc\'c5\'cc
\f0  return 
\f1 \'c0\'e0\'d0\'cd\'ce\'aa
\f0 \'93Search\'94
\f1 \'d7\'d6\'d1\'f9
\f0  \
     // kKeyboardReturnTypeGo: 
\f1 \'c4\'ac\'c8\'cf\'ca\'b9\'d3\'c3\'bc\'fc\'c5\'cc
\f0  return 
\f1 \'c0\'e0\'d0\'cd\'ce\'aa
\f0 \'93Go\'94
\f1 \'d7\'d6\'d1\'f9
\f0 \
    */\cf0 \
    \
    box->\cf8 setDelegate\cf0 (\cf5 this\cf0 );\cf2 //
\f1 \'c9\'e8\'d6\'c3\'b4\'fa\'c0\'ed
\f0 \cf0 \
    \
    \cf5 this\cf0 ->\cf8 addChild\cf0 (box);\
\}\
\cf2 // CCEditBox   4
\f1 \'b8\'f6\'b4\'fa\'c0\'ed\'b7\'bd\'b7\'a8
\f0 \cf0 \
\cf5 void\cf0  \cf7 HelloWorld\cf0 ::editBoxEditingDidBegin(\cf7 CCEditBox\cf0 * editBox)\
\{\
    \cf8 CCLog\cf0 (\cf4 "Begin"\cf0 );\
\}\
\cf5 void\cf0  \cf7 HelloWorld\cf0 ::editBoxEditingDidEnd(\cf7 CCEditBox\cf0 * editBox)\
\{\
     \cf8 CCLog\cf0 (\cf4 "End"\cf0 );\
\}\
\cf5 void\cf0  \cf7 HelloWorld\cf0 ::editBoxTextChanged(\cf7 CCEditBox\cf0 * editBox, \cf5 const\cf0  \cf10 std\cf0 ::\cf10 string\cf0 & text)\
\{\
     \cf8 CCLog\cf0 (\cf4 "Changed"\cf0 );\
\}\
\cf5 void\cf0  \cf7 HelloWorld\cf0 ::editBoxReturn(\cf7 CCEditBox\cf0 * editBox)\
\{\
     \cf8 CCLog\cf0 (\cf4 "Return"\cf0 );\
\}\
\
\
\
\cf2 //
\f1 \'b2\'e2\'ca\'d4\'b0\'b4\'c5\'a5
\f0 \cf0 \
\cf5 void\cf0  \cf7 HelloWorld\cf0 ::testCCControlButton()\
\{\
    \cf7 CCScale9Sprite\cf0  * btnnormal = \cf7 CCScale9Sprite\cf0 ::\cf8 create\cf0 (\cf4 "0.ico"\cf0 );\
    \cf7 CCScale9Sprite\cf0  * btnSelected = \cf7 CCScale9Sprite\cf0 ::\cf8 create\cf0 (\cf4 "2.ico"\cf0 );\
\
    \cf7 CCControlButton\cf0  * btn = \cf7 CCControlButton\cf0 ::\cf8 create\cf0 (btnnormal);\
    \
    btn->\cf8 setPosition\cf0 (\cf7 ccp\cf0 (\cf6 800\cf0 , \cf6 200\cf0 ));\
    \cf2 //
\f1 \'b0\'b4\'c5\'a5\'b4\'f3\'d0\'a1
\f0 \cf0 \
    btn->\cf8 setPreferredSize\cf0 (\cf7 CCSizeMake\cf0 (\cf6 128\cf0 , \cf6 128\cf0 ));\
    \cf2 //
\f1 \'c9\'e8\'d6\'c3\'b0\'b4\'c5\'a5\'b0\'b4\'cf\'c2\'ca\'b1\'b5\'c4\'cd\'bc\'c6\'ac
\f0 \cf0 \
    btn->\cf8 setBackgroundSpriteForState\cf0 (btnSelected, \cf8 CCControlStateHighlighted\cf0 );\
    \cf2 //
\f1 \'b8\'f8\'b0\'b4\'c5\'a5\'cc\'ed\'bc\'d3\'ca\'c2\'bc\'fe
\f0 \cf0 \
    btn->\cf8 addTargetWithActionForControlEvents\cf0 (\cf5 this\cf0 , \cf7 cccontrol_selector\cf0 (\cf7 HelloWorld\cf0 ::\cf8 buttonCallBack\cf0 ),\cf8 CCControlEventTouchUpInside\cf0 );\
    \cf2 //
\f1 \'c9\'e8\'d6\'c3
\f0 Tag\cf0 \
    btn->\cf8 setTag\cf0 (\cf6 10\cf0 );\
    \cf5 this\cf0 ->addChild(btn);\
\}\
\cf2 //
\f1 \'b0\'b4\'c5\'a5\'ca\'c2\'bc\'fe
\f0 \cf0 \
\cf5 void\cf0  \cf7 HelloWorld\cf0 ::buttonCallBack(\cf7 CCObject\cf0  * pSender)\
\{\
    \cf5 int\cf0  n = ((\cf7 CCControlButton\cf0  *)pSender)->\cf8 getTag\cf0 ();\
    \cf8 CCLog\cf0 (\cf4 "Tag : %d"\cf0 ,n);\
    \cf2 //CCControlButton* btn = (CCControlButton *)pSender;\cf0 \
\}\
\
\
\
\cf2 //
\f1 \'b2\'e2\'ca\'d4\'bf\'aa\'b9\'d8
\f0  
\f1 \'bf\'aa\'b9\'d8
\f0 \cf0 \
\cf5 void\cf0  \cf7 HelloWorld\cf0 ::testSwitch()\
\{\
    \cf7 CCControlSwitch\cf0  * switchControl = \cf7 CCControlSwitch\cf0 ::\cf8 create\cf0 (\cf7 CCSprite\cf0 ::\cf8 create\cf0 (\cf4 "switch-mask.png"\cf0 ), \cf7 CCSprite\cf0 ::\cf8 create\cf0 (\cf4 "switch-on.png"\cf0 ), \cf7 CCSprite\cf0 ::\cf8 create\cf0 (\cf4 "switch-off.png"\cf0 ), \cf7 CCSprite\cf0 ::\cf8 create\cf0 (\cf4 "switch-thumb.png"\cf0 ),\cf7 CCLabelTTF\cf0 ::\cf8 create\cf0 (\cf4 "ON"\cf0 , \cf4 "Arial-BoldMT"\cf0 , \cf6 16\cf0 ),\cf7 CCLabelTTF\cf0 ::\cf8 create\cf0 (\cf4 "OFF"\cf0 , \cf4 "Arial-BoldMT"\cf0 ,\cf6 16\cf0 ));\
    switchControl->\cf8 setPosition\cf0 (\cf7 ccp\cf0 (\cf6 480\cf0 , \cf6 320\cf0 ));\
    switchControl->\cf8 addTargetWithActionForControlEvents\cf0 (\cf5 this\cf0 , \cf7 cccontrol_selector\cf0 (\cf7 HelloWorld\cf0 :: \cf8 switchPickerValueChanged\cf0 ), \cf8 CCControlEventValueChanged\cf0 );\
    \cf5 this\cf0 ->\cf8 addChild\cf0 (switchControl);\
\}\
\cf2 //
\f1 \'bf\'aa\'b9\'d8\'b5\'c4\'b5\'e3\'bb\'f7\'ca\'c2\'bc\'fe
\f0 \cf0 \
\cf5 void\cf0  \cf7 HelloWorld\cf0 ::switchPickerValueChanged(\cf7 CCObject\cf0  * sender,\cf7 CCControlEvent\cf0  controlEvent)\
\{\
    \cf7 CCControlSwitch\cf0  * switchControl = (\cf7 CCControlSwitch\cf0 *)sender;\
    \cf5 if\cf0  (switchControl->\cf8 isOn\cf0 ())\
    \{\
        \cf7 SimpleAudioEngine\cf0 ::\cf8 sharedEngine\cf0 ()->\cf8 playBackgroundMusic\cf0 (\cf4 "background.mp3"\cf0 , \cf5 true\cf0 );\
        \cf8 CCLog\cf0 (\cf4 "ON"\cf0 );\
        \
    \}\
    \cf5 else\cf0 \
    \{\
        \cf7 SimpleAudioEngine\cf0 ::\cf8 sharedEngine\cf0 ()->\cf8 pauseBackgroundMusic\cf0 ();\
        \cf8 CCLog\cf0 (\cf4 "OFF"\cf0 );\
    \}\
\}\
\
\
\
\cf2 //
\f1 \'bb\'ac\'bf\'e9
\f0 CCControl\cf0 \
\cf5 void\cf0  \cf7 HelloWorld\cf0 ::testSlider()\
\{\
    \cf2 //
\f1 \'cc\'ed\'bc\'d3
\f0 \cf0 \
    \cf7 CCControlSlider\cf0  * slider = \cf7 CCControlSlider\cf0 ::\cf8 create\cf0 (\cf4 "xuetiao1.png"\cf0 , \cf4 "xuetiao2.png"\cf0 , \cf4 "xuetiao3.png"\cf0 );\
    slider->\cf8 setAnchorPoint\cf0 (\cf7 ccp\cf0 (\cf6 0.5\cf0 , \cf6 0.5\cf0 ));\
    slider->\cf8 setMinimumValue\cf0 (\cf6 0\cf0 );\
    slider->\cf8 setMaximumValue\cf0 (\cf6 100\cf0 );\
    slider->\cf8 setPosition\cf0 (\cf7 ccp\cf0 (\cf6 240\cf0 , \cf6 160\cf0 ));\
    slider->\cf8 setValue\cf0 (\cf6 30\cf0 );\
    slider->\cf8 setTag\cf0 (\cf6 1\cf0 );\
    slider->\cf8 addTargetWithActionForControlEvents\cf0 (\cf5 this\cf0 , \cf7 cccontrol_selector\cf0 (\cf7 HelloWorld\cf0 ::\cf8 sliderCalueChanged\cf0 ), \cf8 CCControlEventValueChanged\cf0 );\
    \cf5 this\cf0 ->\cf8 addChild\cf0 (slider);\
\}\
\cf2 //
\f1 \'bb\'ac\'bf\'e9\'b4\'a5\'c3\'fe\'ca\'c2\'bc\'fe
\f0 \cf0 \
\cf5 void\cf0  \cf7 HelloWorld\cf0 ::sliderCalueChanged(\cf7 CCObject\cf0  * sender,\cf7 CCControlEvent\cf0  controlEvent)\
\{\
    \cf7 CCControlSlider\cf0  * slider = (\cf7 CCControlSlider\cf0  *)sender;\
    \cf8 CCLog\cf0 (\cf4 "Value %.02f"\cf0 ,slider->\cf8 getValue\cf0 ());\
\}\
\
\
\
\cf2 //
\f1 \'d1\'d5\'c9\'ab\'d1\'a1\'d4\'f1\'c5\'cc
\f0 \cf0 \
\cf5 void\cf0  \cf7 HelloWorld\cf0 :: testCColorPicker ()\
\{\
    \cf7 CCControlColourPicker\cf0  *colorPicker = \cf7 CCControlColourPicker\cf0 ::\cf8 create\cf0 ();\
    colorPicker->\cf8 setColor\cf0 (\cf8 ccc3\cf0 (\cf6 37\cf0 , \cf6 25\cf0 , \cf6 86\cf0 ));\
    colorPicker->\cf8 setPosition\cf0 (\cf7 ccp\cf0 (colorPicker->\cf8 getContentSize\cf0 ().\cf7 width\cf0 /\cf6 2\cf0 , \cf6 500\cf0 ));\
    \cf2 //
\f1 \'d7\'a2\'b2\'e1\'ca\'c2\'bc\'fe
\f0 \cf0 \
    colorPicker->\cf8 addTargetWithActionForControlEvents\cf0 (\cf5 this\cf0 , \cf7 cccontrol_selector\cf0 (\cf7 HelloWorld\cf0 ::\cf8 colorPickerValueChanged\cf0 ), \cf8 CCControlEventValueChanged\cf0 );\
    \
    \cf7 CCLabelTTF\cf0  * lable = \cf7 CCLabelTTF\cf0 ::\cf8 create\cf0 (\cf4 "
\f1 \'b2\'e2\'ca\'d4\'d1\'d5\'c9\'ab
\f0 "\cf0 , \cf4 "Arial"\cf0 , \cf6 30\cf0 );\
    lable->\cf8 setPosition\cf0 (\cf7 ccp\cf0 (\cf6 300\cf0 , \cf6 300\cf0 ));\
    lable->\cf8 setTag\cf0 (\cf6 2\cf0 );\
    \
    \
    \cf5 this\cf0 ->\cf8 addChild\cf0 (colorPicker);\
    \cf5 this\cf0 ->\cf8 addChild\cf0 (lable);\
\}\
\cf2 //
\f1 \'d1\'d5\'c9\'ab\'d1\'a1\'d4\'f1\'c5\'cc\'b5\'c4\'b5\'e3\'bb\'f7\'ca\'c2\'bc\'fe
\f0 \cf0 \
\cf5 void\cf0  \cf7 HelloWorld\cf0 :: colorPickerValueChanged(\cf7 CCObject\cf0  * sender,\cf7 CCControlEvent\cf0  controlEvent)\
\{\
    \cf7 CCControlColourPicker\cf0  * colourPicker = (\cf7 CCControlColourPicker\cf0 *)sender;\
    \cf7 CCString\cf0  * str = \cf7 CCString\cf0 ::\cf8 createWithFormat\cf0 (\cf4 "#%02X%02X%02X"\cf0 ,colourPicker->\cf8 getColor\cf0 ().\cf7 r\cf0 ,colourPicker->\cf8 getColor\cf0 ().\cf7 g\cf0 ,colourPicker->\cf8 getColor\cf0 ().\cf7 b\cf0 );\
    \cf8 CCLog\cf0 (\cf4 "str:%s"\cf0 ,str->\cf8 getCString\cf0 ());\
    \
    \
    \
    \cf7 CCLabelTTF\cf0  * lable = (\cf7 CCLabelTTF\cf0  *)\cf5 this\cf0 ->\cf8 getChildByTag\cf0 (\cf6 2\cf0 );\
    lable->\cf8 setColor\cf0 (\cf8 ccc3\cf0 (colourPicker->\cf8 getColor\cf0 ().\cf7 r\cf0 ,colourPicker->\cf8 getColor\cf0 ().\cf7 g\cf0 ,colourPicker->\cf8 getColor\cf0 ().\cf7 b\cf0  ));\
\}\
/////////////////////////////////////////////
\f1 \'b5\'da\'ce\'e5\'cc\'ec
\f0 1\
\cf3 #ifndef __HELLOWORLD_SCENE_H__\
#define __HELLOWORLD_SCENE_H__\
\cf0 \
\cf3 #include \cf4 "cocos2d.h"\cf3 \
\cf0 \
\cf3 USING_NS_CC\cf0 ;\
\
\cf5 class\cf0  HelloWorld : \cf5 public\cf0  \cf7 cocos2d\cf0 ::\cf7 CCLayer\cf0 \
\{\
\cf5 public\cf0 :\
    \cf5 virtual\cf0  \cf5 bool\cf0  init();\
    \cf5 static\cf0  \cf7 cocos2d\cf0 ::\cf7 CCScene\cf0 * scene();\
    \cf5 void\cf0  menuCloseCallback(\cf7 CCObject\cf0 * pSender);\
    \
    \cf2 //touch
\f1 \'b7\'bd\'b7\'a8
\f0 \cf0 \
    \cf5 virtual\cf0  \cf5 bool\cf0  ccTouchBegan(\cf7 CCTouch\cf0  *pTouch, \cf7 CCEvent\cf0  *pEvent);\
    \cf5 virtual\cf0  \cf5 void\cf0  ccTouchMoved(\cf7 CCTouch\cf0  *pTouch, \cf7 CCEvent\cf0  *pEvent);\
    \cf5 virtual\cf0  \cf5 void\cf0  ccTouchEnded(\cf7 CCTouch\cf0  *pTouch, \cf7 CCEvent\cf0  *pEvent);\
    \cf5 virtual\cf0  \cf5 void\cf0  ccTouchCancelled(\cf7 CCTouch\cf0  *pTouch, \cf7 CCEvent\cf0  *pEvent);\
    \
    \cf3 CREATE_FUNC\cf0 (\cf7 HelloWorld\cf0 );\
\};\
\
\cf5 class\cf0  TestLayer:\cf5 public\cf0  \cf7 CCLayer\cf0 \
\{\
\cf5 public\cf0 :\
    \cf5 virtual\cf0  \cf5 bool\cf0  init();\
    \
    \cf2 //touch
\f1 \'b7\'bd\'b7\'a8
\f0 \cf0 \
    \cf5 virtual\cf0  \cf5 bool\cf0  ccTouchBegan(\cf7 CCTouch\cf0  *pTouch, \cf7 CCEvent\cf0  *pEvent);\
    \cf5 virtual\cf0  \cf5 void\cf0  ccTouchMoved(\cf7 CCTouch\cf0  *pTouch, \cf7 CCEvent\cf0  *pEvent);\
    \cf5 virtual\cf0  \cf5 void\cf0  ccTouchEnded(\cf7 CCTouch\cf0  *pTouch, \cf7 CCEvent\cf0  *pEvent);\
    \cf5 virtual\cf0  \cf5 void\cf0  ccTouchCancelled(\cf7 CCTouch\cf0  *pTouch, \cf7 CCEvent\cf0  *pEvent);\
    \
    \cf3 CREATE_FUNC\cf0 (\cf7 TestLayer\cf0 );\
\};\
\
\
\cf3 #include \cf4 "HelloWorldScene.h"\cf3 \
\cf0 \
\cf3 USING_NS_CC\cf0 ;\
\
\pard\tx770\pardeftab770\pardirnatural
\cf7 CCScene\cf0 * \cf7 HelloWorld\cf0 ::scene()\
\{\
    \cf7 CCScene\cf0  *scene = \cf7 CCScene\cf0 ::\cf8 create\cf0 ();\
    \cf7 HelloWorld\cf0  *layer = \cf7 HelloWorld\cf0 ::\cf8 create\cf0 ();\
    scene->\cf8 addChild\cf0 (layer);\
    \cf2 //TestLayer * testlayer = TestLayer::create();\cf0 \
    \cf2 //scene->addChild(testlayer);\cf0 \
    \cf5 return\cf0  scene;\
\}\
\
\pard\tx770\pardeftab770\pardirnatural
\cf5 bool\cf0  \cf7 HelloWorld\cf0 ::init()\
\{\
    \cf5 if\cf0  ( !\cf7 CCLayer\cf0 ::\cf8 init\cf0 () )\
    \{\
        \cf5 return\cf0  \cf5 false\cf0 ;\
    \}\
    \
    \cf2 //CCSprite *\cf0 \
    \
    \
    \cf7 CCMenuItemImage\cf0  * image = \cf7 CCMenuItemImage\cf0 ::\cf8 create\cf0 (\cf4 "CloseNormal.png"\cf0 , \cf4 "CloseSelected.png"\cf0 );\
    \cf2 //image->setPosition(ccp(400, 300));\cf0 \
    image->\cf8 setTarget\cf0 (\cf5 this\cf0 , \cf3 menu_selector\cf0 (\cf7 HelloWorld\cf0 ::\cf8 menuCloseCallback\cf0 ));\
    \cf7 CCMenu\cf0  * menu = \cf7 CCMenu\cf0 ::\cf8 create\cf0 (image,\cf5 NULL\cf0 );\
    menu->\cf8 setPosition\cf0 (\cf3 ccp\cf0 (\cf6 400\cf0 , \cf6 300\cf0 ));\
    menu->\cf8 setTouchPriority\cf0 (\cf6 110\cf0 );\
    \cf5 this\cf0 ->\cf8 addChild\cf0 (menu,\cf6 1\cf0 );\
    \
    \
    \cf2 //
\f1 \'b4\'a5\'c3\'fe\'d7\'a2\'b2\'e1
\f0 \cf0 \
    \cf7 CCDirector\cf0 ::\cf8 sharedDirector\cf0 ()->\cf8 getTouchDispatcher\cf0 ()->\cf8 addTargetedDelegate\cf0 (\cf5 this\cf0 , \cf6 0\cf0 , \cf5 false\cf0 );\
    \
    \cf7 TestLayer\cf0  * layer = \cf7 TestLayer\cf0 ::\cf8 create\cf0 ();\
    \cf5 this\cf0 ->\cf8 addChild\cf0 (layer);\
    \
    \cf5 return\cf0  \cf5 true\cf0 ;\
\}\
\
\cf5 void\cf0  \cf7 HelloWorld\cf0 ::menuCloseCallback(\cf7 CCObject\cf0 * pSender)\
\{\
    \cf8 CCLog\cf0 (\cf4 ">>>>>>>>>>>>>>>"\cf0 );\
\}\
\
\
\cf5 bool\cf0  \cf7 HelloWorld\cf0 :: ccTouchBegan(\cf7 CCTouch\cf0  *pTouch, \cf7 CCEvent\cf0  *pEvent)\
\{\
    \cf8 CCLog\cf0 (\cf4 "ccTouchBegan"\cf0 );\
    \cf2 //return false;//
\f1 \'b5\'a5\'cf\'ee\'b4\'a5\'c3\'fe\'a3\'ac\'d6\'ae\'ba\'f3\'b5\'c4\'b6\'af\'d7\'f7\'b2\'bb\'d6\'b4\'d0\'d0
\f0 \cf0 \
    \cf5 return\cf0  \cf5 true\cf0 ;\
\}\
\cf5 void\cf0  \cf7 HelloWorld\cf0 ::ccTouchMoved(\cf7 CCTouch\cf0  *pTouch, \cf7 CCEvent\cf0  *pEvent)\
\{\
    \cf8 CCLog\cf0 (\cf4 "ccTouchMoved"\cf0 );\
\}\
\cf5 void\cf0  \cf7 HelloWorld\cf0 ::ccTouchEnded(\cf7 CCTouch\cf0  *pTouch, \cf7 CCEvent\cf0  *pEvent)\
\{\
    \cf8 CCLog\cf0 (\cf4 "ccTouchEnded"\cf0 );\
\}\
\cf2 //
\f1 \'b3\'cc\'d0\'f2\'b3\'a4\'ca\'b1\'bc\'e4\'b2\'bb\'cf\'ec\'d3\'a6\'ba\'f3\'d5\'df\'c0\'b4\'b5\'e7\'bb\'b0\'b5\'c4\'ca\'b1\'ba\'f2\'ca\'b9\'d3\'c3
\f0 \cf0 \
\cf5 void\cf0  \cf7 HelloWorld\cf0 ::ccTouchCancelled(\cf7 CCTouch\cf0  *pTouch, \cf7 CCEvent\cf0  *pEvent)\
\{\
    \cf8 CCLog\cf0 (\cf4 "ccTouchCancelled"\cf0 );\
\}\
\
\
\cf5 bool\cf0  \cf7 TestLayer\cf0 ::init()\
\{\
    \cf5 if\cf0  ( !\cf7 CCLayer\cf0 ::\cf8 init\cf0 () )\
    \{\
        \cf5 return\cf0  \cf5 false\cf0 ;\
    \}\
    \cf2 //
\f1 \'b4\'a5\'c3\'fe\'d7\'a2\'b2\'e1
\f0 \cf0 \
    \cf7 CCDirector\cf0 ::\cf8 sharedDirector\cf0 ()->\cf8 getTouchDispatcher\cf0 ()->\cf8 addTargetedDelegate\cf0 (\cf5 this\cf0 , -\cf6 120\cf0 , \cf5 true\cf0 );\
    \cf5 return\cf0  \cf5 true\cf0 ;\
\}\
\cf5 bool\cf0  \cf7 TestLayer\cf0 :: ccTouchBegan(\cf7 CCTouch\cf0  *pTouch, \cf7 CCEvent\cf0  *pEvent)\
\{\
    \cf2 //pTouch->getLocation()
\f1 \'a3\'bb
\f0 \cf0 \
    \cf8 CCLog\cf0 (\cf4 "TestLayer   ccTouchBegan"\cf0 );\
    \cf2 //return false;//
\f1 \'b5\'a5\'cf\'ee\'b4\'a5\'c3\'fe\'a3\'ac\'d6\'ae\'ba\'f3\'b5\'c4\'b6\'af\'d7\'f7\'b2\'bb\'d6\'b4\'d0\'d0
\f0 \cf0 \
    \cf5 return\cf0  \cf5 true\cf0 ;\
\}\
\cf5 void\cf0  \cf7 TestLayer\cf0 ::ccTouchMoved(\cf7 CCTouch\cf0  *pTouch, \cf7 CCEvent\cf0  *pEvent)\
\{\
    \cf8 CCLog\cf0 (\cf4 "TestLayer   ccTouchMoved"\cf0 );\
\}\
\cf5 void\cf0  \cf7 TestLayer\cf0 ::ccTouchEnded(\cf7 CCTouch\cf0  *pTouch, \cf7 CCEvent\cf0  *pEvent)\
\{\
    \cf8 CCLog\cf0 (\cf4 "TestLayer   ccTouchEnded"\cf0 );\
\}\
\cf2 //
\f1 \'b3\'cc\'d0\'f2\'b3\'a4\'ca\'b1\'bc\'e4\'b2\'bb\'cf\'ec\'d3\'a6\'ba\'f3\'d5\'df\'c0\'b4\'b5\'e7\'bb\'b0\'b5\'c4\'ca\'b1\'ba\'f2\'ca\'b9\'d3\'c3
\f0 \cf0 \
\cf5 void\cf0  \cf7 TestLayer\cf0 ::ccTouchCancelled(\cf7 CCTouch\cf0  *pTouch, \cf7 CCEvent\cf0  *pEvent)\
\{\
    \cf8 CCLog\cf0 (\cf4 "TestLayer   ccTouchCancelled"\cf0 );\
\}\
\
\cf3 #endif \cf0 \
\
////////////////////////////////////////////
\f1 \'b5\'da\'ce\'e5\'cc\'ec
\f0 2\
\cf3 #include \cf4 "HelloWorldScene.h"\cf3 \
\cf0 \
\cf3 USING_NS_CC\cf0 ;\
\
\pard\tx770\pardeftab770\pardirnatural
\cf7 CCScene\cf0 * \cf7 HelloWorld\cf0 ::scene()\
\{\
    \cf2 // 'scene' is an autorelease object\cf0 \
    \cf7 CCScene\cf0  *scene = \cf7 CCScene\cf0 ::\cf8 create\cf0 ();\
    \
    \cf2 // 'layer' is an autorelease object\cf0 \
    \cf7 HelloWorld\cf0  *layer = \cf7 HelloWorld\cf0 ::\cf8 create\cf0 ();\
\
    \cf2 // add layer as a child to scene\cf0 \
    scene->\cf8 addChild\cf0 (layer);\
\
    \cf2 // return the scene\cf0 \
    \cf5 return\cf0  scene;\
\}\
\
\pard\tx770\pardeftab770\pardirnatural
\cf2 // on "init" you need to initialize your instance\cf0 \
\cf5 bool\cf0  \cf7 HelloWorld\cf0 ::init()\
\{\
    \cf5 if\cf0  ( !\cf7 CCLayer\cf0 ::\cf8 init\cf0 () )\
    \{\
        \cf5 return\cf0  \cf5 false\cf0 ;\
    \}\
    \
    \cf7 winize\cf0  = \cf7 CCDirector\cf0 ::\cf8 sharedDirector\cf0 ()->\cf8 getVisibleSize\cf0 ();\
    \
    \cf2 //
\f1 \'bb\'ac\'b6\'af\'d2\'b3\'c3\'e6
\f0 \cf0 \
    \cf7 scrolView\cf0  = \cf7 CCScrollView\cf0 ::\cf8 create\cf0 (\cf3 CCSizeMake\cf0 (\cf7 winize\cf0 .\cf7 width\cf0 , \cf7 winize\cf0 .\cf7 height\cf0 ));\
    \cf7 CCLayer\cf0  * layer = \cf7 CCLayer\cf0 ::\cf8 create\cf0 ();\
    layer->\cf8 setContentSize\cf0 (\cf3 CCSizeMake\cf0 (\cf7 winize\cf0 .\cf7 width\cf0 *\cf6 10\cf0 , \cf7 winize\cf0 .\cf7 height\cf0 ));\
    \cf5 for\cf0  (\cf5 int\cf0  n = \cf6 0\cf0 ; n<\cf6 10\cf0 ; n++)\
    \{\
        \cf7 CCSprite\cf0  * sp = \cf7 CCSprite\cf0 ::\cf8 create\cf0 (\cf4 "HelloWorld.png"\cf0 );\
        sp->\cf8 setScale\cf0 (\cf6 0.5f\cf0 );\
        sp->\cf8 setPosition\cf0 (\cf3 ccp\cf0 (winize.width/\cf6 2\cf0  + n*winize.width ,\cf7 winize\cf0 .\cf7 height\cf0  /\cf6 2\cf0 ));\
        layer->\cf8 addChild\cf0 (sp);\
    \}\
    \cf7 scrolView\cf0 ->\cf8 setContainer\cf0 (layer);\
    \cf7 scrolView\cf0 ->\cf8 setBounceable\cf0 (\cf5 false\cf0 );\cf2 //
\f1 \'ca\'c7\'b7\'f1\'d3\'d0\'b5\'af\'d0\'d4
\f0 \cf0 \
    \cf7 scrolView\cf0 ->\cf8 setDirection\cf0 (\cf8 kCCScrollViewDirectionHorizontal\cf0 );\
    \cf5 this\cf0 ->\cf8 addChild\cf0 (\cf7 scrolView\cf0 );\
\
    \cf5 return\cf0  \cf5 true\cf0 ;\
\}\
\cf2 //
\f1 \'bd\'c3\'d5\'fd\'c6\'ab\'d2\'c6
\f0 \cf0 \
\cf5 void\cf0  \cf7 HelloWorld\cf0 ::adjustScrollView()\
\{\
    \cf2 //
\f1 \'b9\'d8\'b1\'d5\'d7\'d4\'b5\'f7\'d5\'fb
\f0 \cf0 \
    \cf7 scrolView\cf0 ->\cf8 unscheduleAllSelectors\cf0 ();\
    \cf2 //
\f1 \'bb\'f1\'c8\'a1\'b5\'b1\'c7\'b0\'c6\'ab\'d2\'c6\'c1\'bf
\f0 \cf0 \
    \cf7 layerX\cf0 = \cf7 scrolView\cf0 ->\cf8 getContentOffset\cf0 ().\cf7 x\cf0 ;\
    \cf2 //
\f1 \'b5\'b1\'c7\'b0\'bb\'ac\'b6\'af\'d0\'e8\'d2\'aa\'b5\'f7\'d5\'fb\'b5\'c4\'ce\'bb\'d2\'c6
\f0 \cf0 \
    \cf5 int\cf0  offset = (\cf5 int\cf0 )\cf7 layerX\cf0  % (\cf5 int\cf0 )\cf7 winize\cf0 .\cf7 width\cf0 ;\
    \cf2 //
\f1 \'b5\'f7\'d5\'fb\'ba\'f3\'b5\'c4\'ce\'bb\'d6\'c3
\f0 \cf0 \
    \cf7 CCPoint\cf0  adjustPoint;\
    \cf2 //
\f1 \'b5\'f7\'d5\'fb\'cb\'f9\'d0\'e8\'d2\'aa\'b5\'c4\'ca\'b1\'bc\'e4
\f0 \cf0 \
    \cf5 float\cf0  adjustAnimDelay;\
    \
    \cf2 //
\f1 \'cf\'f2\'d7\'f3\'b4\'f3\'b7\'f9\'b6\'c8\'c6\'ab\'d2\'c6
\f0  
\f1 \'ba\'cd
\f0  
\f1 \'cf\'f2\'d3\'d2\'d0\'a1\'b7\'f9\'b6\'c8\'c6\'ab\'d2\'c6
\f0 \cf0 \
    \cf5 if\cf0  (offset < -\cf6 200\cf0 )\
    \{\
        adjustPoint = \cf8 ccpSub\cf0 (\cf7 scrolView\cf0 ->\cf8 getContentOffset\cf0 (), \cf3 ccp\cf0 (\cf6 480\cf0 +offset,\cf6 0\cf0 ));\
        adjustAnimDelay = (\cf5 float\cf0 )(\cf6 480\cf0  + offset)/\cf6 800\cf0 ;\
    \}\
    \cf2 //
\f1 \'cf\'f2\'d3\'d2\'b4\'f3\'b7\'f9\'b6\'c8\'bb\'ac\'b6\'af
\f0  
\f1 \'cf\'f2\'d7\'f3\'d0\'a1\'b7\'f9\'b6\'c8\'bb\'ac\'b6\'af
\f0 \cf0 \
    \cf5 else\cf0 \
    \{\
        adjustPoint = \cf8 ccpSub\cf0 (\cf7 scrolView\cf0 ->\cf8 getContentOffset\cf0 (), \cf3 ccp\cf0 (offset,\cf6 0\cf0 ));\
        \cf2 //
\f1 \'c8\'a1\'be\'f8\'b6\'d4\'d6\'b5
\f0 \cf0 \
        adjustAnimDelay = (\cf5 float\cf0 )\cf9 abs\cf0 (offset)/\cf6 800\cf0 ;\
    \}\
    \cf7 scrolView\cf0 ->\cf8 setContentOffsetInDuration\cf0 (adjustPoint, adjustAnimDelay);\
\}\
\
\cf5 void\cf0  \cf7 HelloWorld\cf0 ::onEnter()\
\{\
    \cf7 CCDirector\cf0 ::\cf8 sharedDirector\cf0 ()->\cf8 getTouchDispatcher\cf0 ()->\cf8 addTargetedDelegate\cf0 (\cf5 this\cf0 , \cf6 0\cf0 , \cf5 false\cf0 );\
    \cf7 CCLayer\cf0 ::\cf8 onEnter\cf0 ();\
\}\
\cf5 void\cf0  \cf7 HelloWorld\cf0 ::onExit()\
\{\
    \cf7 CCLayer\cf0 ::\cf8 onExit\cf0 ();\
\}\
\
\cf5 bool\cf0  \cf7 HelloWorld\cf0 ::ccTouchBegan(\cf7 CCTouch\cf0  *pTouch, \cf7 CCEvent\cf0  *pEvent)\
\{\
    \cf8 CCLog\cf0 (\cf4 "ccTouchBegan"\cf0 );\
    \cf5 return\cf0  \cf5 true\cf0 ;\
\}\
\cf5 void\cf0  \cf7 HelloWorld\cf0 ::ccTouchMoved(\cf7 CCTouch\cf0  *pTouch, \cf7 CCEvent\cf0  *pEvent)\
\{\
    \cf8 CCLog\cf0 (\cf4 "ccTouchMoved"\cf0 );\
\}\
\cf5 void\cf0  \cf7 HelloWorld\cf0 ::ccTouchEnded(\cf7 CCTouch\cf0  *pTouch, \cf7 CCEvent\cf0  *pEvent)\
\{\
    \cf8 adjustScrollView\cf0 ();\
    \cf8 CCLog\cf0 (\cf4 "ccTouchEnded"\cf0 );\
\}\
\cf5 void\cf0  \cf7 HelloWorld\cf0 ::ccTouchCancelled(\cf7 CCTouch\cf0  *pTouch, \cf7 CCEvent\cf0  *pEvent)\
\{\
    \cf8 CCLog\cf0 (\cf4 "ccTouchCancelled"\cf0 );\
\}\
\
/////////////////////////
\f1 \'b5\'da\'c1\'f9\'cc\'ec
\f0 \
\cf3 #ifndef __HELLOWORLD_SCENE_H__\
#define __HELLOWORLD_SCENE_H__\
\cf0 \
\cf3 #include \cf4 "cocos2d.h"\cf3 \
#include \cf4 <cocos-ext.h>\cf3 \
USING_NS_CC\cf0 ;\
\cf3 USING_NS_CC_EXT\cf0 ;\
\cf5 class\cf0  HelloWorld : \cf5 public\cf0  \cf7 cocos2d\cf0 ::\cf10 CCLayer\cf0 ,\cf5 public\cf0  \cf7 CCTableViewDelegate\cf0 ,\cf5 public\cf0  \cf7 CCTableViewDataSource\cf0 \
\{\
\cf5 public\cf0 :\
    \cf5 virtual\cf0  \cf5 bool\cf0  init();\
    \cf5 static\cf0  \cf7 cocos2d\cf0 ::\cf10 CCScene\cf0 * scene();\
    \cf5 void\cf0  menuCloseCallback(\cf10 CCObject\cf0 * pSender);\
    \cf3 CREATE_FUNC\cf0 (\cf7 HelloWorld\cf0 );\
    \
    \
    \cf2 //Delegate\cf0 \
    \cf5 virtual\cf0  \cf5 void\cf0  tableCellTouched(\cf7 CCTableView\cf0 * table, \cf7 CCTableViewCell\cf0 * cell);\
    \cf2 //DataSource\cf0 \
    \cf5 virtual\cf0  \cf7 CCTableViewCell\cf0 * tableCellAtIndex(\cf7 CCTableView\cf0  *table, \cf5 unsigned\cf0  \cf5 int\cf0  idx);\
    \cf5 virtual\cf0  \cf5 unsigned\cf0  \cf5 int\cf0  numberOfCellsInTableView(\cf7 CCTableView\cf0  *table);\
    \cf2 //CCScrollViewDelegate\cf0 \
    \cf5 virtual\cf0  \cf5 void\cf0  scrollViewDidScroll(\cf7 CCScrollView\cf0 * view);\
    \cf5 virtual\cf0  \cf5 void\cf0  scrollViewDidZoom(\cf7 CCScrollView\cf0 * view);\
    \cf5 virtual\cf0  \cf10 CCSize\cf0  cellSizeForTable(\cf7 CCTableView\cf0  *table) ;\
\cf5 private\cf0 :\
    \cf7 CCTableView\cf0  * tableView ;\
    \
\};\
\
\cf3 #endif \cf2 // __HELLOWORLD_SCENE_H__\
\
\
\cf0 \
\cf3 #include \cf4 "HelloWorldScene.h"\cf3 \
#include \cf4 "cocos2d.h"\cf3 \
#include \cf4 <cocos-ext.h>\cf3 \
USING_NS_CC\cf0 ;\
\cf3 USING_NS_CC_EXT\cf0 ;\
\
\pard\tx770\pardeftab770\pardirnatural
\cf10 CCScene\cf0 * \cf7 HelloWorld\cf0 ::scene()\
\{\
    \cf2 // 'scene' is an autorelease object\cf0 \
    \cf10 CCScene\cf0  *scene = \cf10 CCScene\cf0 ::\cf9 create\cf0 ();\
    \
    \cf2 // 'layer' is an autorelease object\cf0 \
    \cf7 HelloWorld\cf0  *layer = \cf7 HelloWorld\cf0 ::\cf8 create\cf0 ();\
\
    \cf2 // add layer as a child to scene\cf0 \
    scene->\cf9 addChild\cf0 (layer);\
\
    \cf2 // return the scene\cf0 \
    \cf5 return\cf0  scene;\
\}\
\
\pard\tx770\pardeftab770\pardirnatural
\cf2 // on "init" you need to initialize your instance\cf0 \
\cf5 bool\cf0  \cf7 HelloWorld\cf0 ::init()\
\{\
    \cf2 //////////////////////////////\cf0 \
    \cf2 // 1. super init first\cf0 \
    \cf5 if\cf0  ( !\cf10 CCLayer\cf0 ::\cf9 init\cf0 () )\
    \{\
        \cf5 return\cf0  \cf5 false\cf0 ;\
    \}\
    \cf7 tableView\cf0  = \cf7 CCTableView\cf0 ::\cf8 create\cf0 (\cf5 this\cf0 , \cf3 CCSizeMake\cf0 (\cf6 960\cf0 , \cf6 640\cf0 ));\
    \cf7 tableView\cf0 ->\cf8 setDirection\cf0 (\cf8 kCCScrollViewDirectionVertical\cf0 );\
    \cf7 tableView\cf0 ->\cf8 setVerticalFillOrder\cf0 (\cf8 kCCTableViewFillTopDown\cf0 );\
    \cf7 tableView\cf0 ->\cf9 setPosition\cf0 (\cf6 0\cf0 ,\cf6 0\cf0 );\
    \cf2 //tableView->setAnchorPoint(ccp(0,0));\cf0 \
    \cf7 tableView\cf0 ->\cf8 setDelegate\cf0 (\cf5 this\cf0 );\
    \cf2 //tableView->setDataSource(this);\cf0 \
    \
    \cf5 this\cf0 ->\cf9 addChild\cf0 (\cf7 tableView\cf0 );\
    \
    \
    \cf5 return\cf0  \cf5 true\cf0 ;\
\}\
\
\
\cf2 //Delegate\cf0 \
\cf5 void\cf0  \cf7 HelloWorld\cf0 ::tableCellTouched(\cf7 CCTableView\cf0 * table, \cf7 CCTableViewCell\cf0 * cell)\
\{\
    \cf9 CCLog\cf0 (\cf4 " cell index : %d"\cf0 ,cell->\cf8 getIdx\cf0 ());\
\}\
\cf2 //DataSource\cf0 \
\cf2 //
\f1 \'c4\'da\'c8\'dd
\f0 \cf0 \
\pard\tx770\pardeftab770\pardirnatural
\cf7 CCTableViewCell\cf0 * \cf7 HelloWorld\cf0 ::tableCellAtIndex(\cf7 CCTableView\cf0  *table, \cf5 unsigned\cf0  \cf5 int\cf0  idx)\
\{\
    \cf7 CCTableViewCell\cf0  * cell = table->\cf8 dequeueCell\cf0 ();\cf2 //
\f1 \'bb\'f1\'c8\'a1\'bf\'c9\'d6\'d8\'d3\'c3\'b5\'c4
\f0 cell\cf0 \
    \cf5 if\cf0  (cell == \cf5 NULL\cf0 )\
    \{\
        cell = \cf5 new\cf0  \cf7 CCTableViewCell\cf0 ();\
        cell->\cf9 autorelease\cf0 ();\
        \cf10 CCSprite\cf0  * sp = \cf10 CCSprite\cf0 ::\cf9 create\cf0 (\cf4 "Icon-57.png"\cf0 );\
        sp->\cf9 setPosition\cf0 (\cf3 ccp\cf0 (\cf6 20\cf0 ,\cf6 20\cf0 ));\
        cell->\cf9 addChild\cf0 (sp);\
        \
        \cf10 CCLabelTTF\cf0  * lable = \cf10 CCLabelTTF\cf0 ::\cf9 create\cf0 (\cf4 "Test"\cf0 , \cf4 "Arial"\cf0 , \cf6 20\cf0 );\
        lable->\cf9 setPosition\cf0 (\cf3 ccp\cf0 (\cf6 200\cf0 , \cf6 10\cf0 ));\
        lable->\cf9 setTag\cf0 (\cf6 10\cf0 );\
        cell->\cf9 addChild\cf0 (lable);\
    \}\
    \cf5 else\cf0 \
    \{\
        \cf2 //cell->removeAllChildren();\cf0 \
        \cf10 CCLabelTTF\cf0  * lable = (\cf10 CCLabelTTF\cf0 *)cell->\cf9 getChildByTag\cf0 (\cf6 10\cf0 );\
        lable->\cf9 setString\cf0 (\cf4 "aaaaaaa"\cf0 );\
    \}\
    \cf5 return\cf0  cell;\
\}\
\pard\tx770\pardeftab770\pardirnatural
\cf2 //
\f1 \'b4\'f3\'d0\'a1
\f0  
\f1 \'d7\'dc\'b9\'b2\'b6\'e0\'c9\'d9\'cf\'ee
\f0 \cf0 \
\cf5 unsigned\cf0  \cf5 int\cf0  \cf7 HelloWorld\cf0 ::numberOfCellsInTableView(\cf7 CCTableView\cf0  *table)\
\{\
    \cf5 return\cf0  \cf6 10\cf0 ;\
\}\
\pard\tx770\pardeftab770\pardirnatural
\cf10 CCSize\cf0  \cf7 HelloWorld\cf0 ::cellSizeForTable(\cf7 CCTableView\cf0  *table)\
\{\
    \cf5 return\cf0  \cf3 CCSizeMake\cf0 (\cf6 960\cf0 , \cf6 100\cf0 );\
\}\
\pard\tx770\pardeftab770\pardirnatural
\cf2 //CCScrollViewDelegate\cf0 \
\cf5 void\cf0  \cf7 HelloWorld\cf0 ::scrollViewDidScroll(\cf7 CCScrollView\cf0 * view)\
\{\
    \
\}\
\cf5 void\cf0  \cf7 HelloWorld\cf0 ::scrollViewDidZoom(\cf7 CCScrollView\cf0 * view)\
\{\
    \
\}\
\
\
\pard\tx770\pardeftab770\pardirnatural

\f1 \cf0 //////////////////////ccb\
\pard\tx770\pardeftab770\pardirnatural

\f0 \cf2 //\cf0 \
\cf2 //  ccpTest.h\cf0 \
\cf2 //  sixth\cf0 \
\cf2 //\cf0 \
\cf2 //  Created by user on 14-9-9.\cf0 \
\cf2 //\cf0 \
\cf2 //\cf0 \
\
\cf3 #ifndef __sixth__ccpTest__\
#define __sixth__ccpTest__\
\cf0 \
\cf3 #include \cf4 "cocos2d.h"\cf3 \
#include \cf4 <cocos-ext.h>\cf3 \
USING_NS_CC\cf0 ;\
\cf3 USING_NS_CC_EXT\cf0 ;\
\cf5 class\cf0  ccpTest : \cf5 public\cf0  \cf7 cocos2d\cf0 ::\cf10 CCLayer\cf0 ,\cf5 public\cf0  \cf7 CCBMemberVariableAssigner\cf0 ,\cf5 public\cf0  \cf7 CCBSelectorResolver\cf0 ,\cf5 public\cf0  \cf7 CCNodeLoaderListener\cf0 \
\{\
\cf5 public\cf0 :\
    \cf5 virtual\cf0  \cf5 bool\cf0  init();\
    \cf5 static\cf0  \cf7 cocos2d\cf0 ::\cf10 CCScene\cf0 * scene();\
    \cf3 CREATE_FUNC\cf0 (\cf7 ccpTest\cf0 );\
    \
    \cf2 //CCBMemberVariableAssigner\cf0 \
    \cf5 virtual\cf0  \cf5 bool\cf0  onAssignCCBMemberVariable(\cf10 CCObject\cf0 * pTarget, \cf5 const\cf0  \cf5 char\cf0 * pMemberVariableName, \cf10 CCNode\cf0 * pNode);\
    \cf2 //CCBSelectorResolver\cf0 \
    \cf5 virtual\cf0  \cf10 SEL_MenuHandler\cf0  onResolveCCBCCMenuItemSelector(\cf10 CCObject\cf0  * pTarget, \cf5 const\cf0  \cf5 char\cf0 * pSelectorName);\
    \cf5 virtual\cf0  \cf10 SEL_CallFuncN\cf0  onResolveCCBCCCallFuncSelector(\cf10 CCObject\cf0  * pTarget, \cf5 const\cf0  \cf5 char\cf0 * pSelectorName);\
    \cf5 virtual\cf0  \cf7 SEL_CCControlHandler\cf0  onResolveCCBCCControlSelector(\cf10 CCObject\cf0  * pTarget, \cf5 const\cf0  \cf5 char\cf0 * pSelectorName);\
    \
    \cf2 //CCNodeLoaderListener//
\f1 \'b0\'f3\'b6\'a8\'cd\'ea\'b3\'c9\'c1\'a2\'bc\'b4\'b5\'f7\'d3\'c3
\f0 \cf0 \
    \cf5 virtual\cf0  \cf5 void\cf0  onNodeLoaded(\cf10 CCNode\cf0  * pNode, \cf7 CCNodeLoader\cf0  * pNodeLoader);\
    \
    \cf10 CCLabelTTF\cf0  * myLabel;\
    \cf7 CCBAnimationManager\cf0  * manager;\
    \cf5 void\cf0  menuCloseCallback(\cf10 CCObject\cf0 * pSender);\
    \
    \cf7 CCBAnimationManager\cf0  * animationManager;\
    \cf5 void\cf0  setAnimationmanger(\cf7 CCBAnimationManager\cf0  * pAnimationManager);\
\};\
\
\
\cf5 class\cf0  HeaderlayerLoader : \cf5 public\cf0  \cf7 CCLayerLoader\cf0 \
\{\
\cf5 public\cf0 :\
    \cf2 //
\f1 \'b4\'b4\'bd\'a8\'d2\'bb\'b8\'f6\'c3\'fb\'d7\'d6\'ce\'aa
\f0 loader
\f1 \'b5\'c4\'ba\'af\'ca\'fd\'a3\'ac\'d5\'e2\'b8\'f6\'ba\'af\'ca\'fd\'b4\'b4\'bd\'a8\'c1\'cb\'d2\'bb\'b8\'f6
\f0 HeaderlayerLoader
\f1 \'b5\'c4\'b6\'d4\'cf\'f3\'a3\'ac\'b2\'a2\'b7\'b5\'bb\'d8\'d5\'e2\'b8\'f6\'b6\'d4\'cf\'f3\'a1\'a3
\f0 \cf0 \
    \cf3 CCB_STATIC_NEW_AUTORELEASE_OBJECT_METHOD\cf0 (\cf7 HeaderlayerLoader\cf0 , loader);\
\cf5 protected\cf0 :\
    \cf2 //
\f1 \'d5\'e2\'b8\'f6\'ba\'ea\'b6\'a8\'d2\'e5\'c1\'cb\'d2\'bb\'b8\'f6\'ba\'af\'ca\'fd\'a3\'ac\'d5\'e2\'b8\'f6\'ba\'af\'ca\'fd\'b7\'b5\'bb\'d8
\f0 Headerlayer
\f1 \'b5\'c4\'b6\'d4\'cf\'f3
\f0 \cf0 \
    \cf3 CCB_VIRTUAL_NEW_AUTORELEASE_CREATECCNODE_METHOD\cf0 (\cf7 ccpTest\cf0 );\
\};\
\
\
\cf3 #endif\cf0 \
\
\cf2 //\cf0 \
\cf2 //  ccpTest.cpp\cf0 \
\cf2 //  sixth\cf0 \
\cf2 //\cf0 \
\cf2 //  Created by user on 14-9-9.\cf0 \
\cf2 //\cf0 \
\cf2 //\cf0 \
\
\cf3 #include \cf4 "ccpTest.h"\cf3 \
#include \cf4 "cocos2d.h"\cf3 \
#include \cf4 <cocos-ext.h>\cf3 \
\pard\tx770\pardeftab770\pardirnatural
\cf7 USING_NS_CC\cf0 ;\
\cf7 USING_NS_CC_EXT\cf0 ;\
\
\cf7 CCScene\cf0 * \cf7 ccpTest\cf0 ::scene()\
\{\
    \cf2 //
\f1 \'bc\'d3\'d4\'d8\'bd\'da\'b5\'e3\'bf\'e2\'a3\'a8\'bd\'ab\'ce\'c4\'bc\'fe\'d3\'eb\'d5\'e2\'b8\'f6\'c0\'e0\'cf\'e0\'c1\'ac\'a3\'a9
\f0 \cf0 \
    \cf7 CCNodeLoaderLibrary\cf0 ::\cf8 sharedCCNodeLoaderLibrary\cf0 ()->\cf8 registerCCNodeLoader\cf0 (\cf4 "HelloLayer"\cf0 , \cf7 HeaderlayerLoader\cf0 ::\cf8 loader\cf0 ());\
    \cf2 //CCBReader
\f1 \'d5\'e2\'b8\'f6\'c0\'e0\'ca\'c7
\f0 COcos2d-x
\f1 \'d7\'a8\'c3\'c5\'d3\'c3\'c0\'b4\'bc\'d3\'d4\'d8
\f0 cocosbuilder
\f1 \'ce\'c4\'bc\'fe\'b5\'c4
\f0 \cf0 \
    CCBReader * reader = \cf5 new\cf0  CCBReader(CCNodeLoaderLibrary::sharedCCNodeLoaderLibrary());\
    reader->\cf8 autorelease\cf0 ();\
    \
    \cf2 //
\f1 \'b4\'d3
\f0 cocosbuilder
\f1 \'b4\'b4\'bd\'a8\'b5\'c4
\f0  
\f1 \'b3\'a1\'be\'b0\'d6\'d0\'b6\'c1\'c8\'a1\'b6\'af\'bb\'ad\'bd\'f8\'d0\'d0\'b0\'f3\'b6\'a8
\f0 \cf0 \
    \cf7 CCNode\cf0  * node = (\cf7 CCNode\cf0 *)reader->\cf8 readNodeGraphFromFile\cf0 (\cf4 "MainScene.ccbi"\cf0 );\
    \
    \cf2 //
\f1 \'c9\'e8\'d6\'c3\'b6\'af\'d7\'f7\'b9\'dc\'c0\'ed\'c6\'f7
\f0 \cf0 \
    ((\cf7 ccpTest\cf0 *)node)->\cf8 setAnimationmanger\cf0 ((reader->\cf8 getAnimationManager\cf0 ()));\
    \
    \
    \
    \cf2 //
\f1 \'cc\'ed\'bc\'d3\'b5\'bd\'b3\'a1\'be\'b0\'d6\'d0
\f0 \cf0 \
    \cf7 CCScene\cf0  *scene = \cf7 CCScene\cf0 ::\cf8 create\cf0 ();\
    \cf5 if\cf0  (node != \cf5 NULL\cf0 )\
    \{\
        scene->\cf8 addChild\cf0 (node);\
    \}\
    \
    \cf5 return\cf0  scene;\
\}\
\
\pard\tx770\pardeftab770\pardirnatural
\cf2 // on "init" you need to initialize your instance\cf0 \
\cf5 bool\cf0  \cf7 ccpTest\cf0 ::init()\
\{\
    \cf2 //////////////////////////////\cf0 \
    \cf2 // 1. super init first\cf0 \
    \cf5 if\cf0  ( !\cf7 CCLayer\cf0 ::\cf8 init\cf0 () )\
    \{\
        \cf5 return\cf0  \cf5 false\cf0 ;\
    \}\
    \
    \
    \
    \cf2 //\cf0 \
    \cf5 return\cf0  \cf5 true\cf0 ;\
\}\
\
\
\
\cf2 //CCBMemberVariableAssigner\cf0 \
\cf5 bool\cf0  \cf7 ccpTest\cf0 ::onAssignCCBMemberVariable(\cf7 CCObject\cf0 * pTarget, \cf5 const\cf0  \cf5 char\cf0 * pMemberVariableName, \cf7 CCNode\cf0 * pNode)\
\{\
    \cf8 CCB_MEMBERVARIABLEASSIGNER_GLUE\cf0 (\cf5 this\cf0 ,\cf4 "helloLabel"\cf0  , \cf7 CCLabelTTF\cf0 *, \cf7 myLabel\cf0  );\
    \cf5 return\cf0  \cf5 true\cf0 ;\
\}\
\cf2 //CCBSelectorResolver\cf0 \
\pard\tx770\pardeftab770\pardirnatural
\cf7 SEL_MenuHandler\cf0  \cf7 ccpTest\cf0 ::onResolveCCBCCMenuItemSelector(\cf7 CCObject\cf0  * pTarget, \cf5 const\cf0  \cf5 char\cf0 * pSelectorName)\
\{\
    \cf8 CCLog\cf0 (\cf4 "onResolveCCBCCMenuItemSelector"\cf0 );\
    \cf7 CCB_SELECTORRESOLVER_CCMENUITEM_GLUE\cf0 (\cf5 this\cf0 , \cf4 "onPressButton"\cf0 , \cf7 ccpTest\cf0 ::\cf8 menuCloseCallback\cf0 );\
    \cf5 return\cf0  \cf5 NULL\cf0 ;\
\}\
\cf7 SEL_CallFuncN\cf0  \cf7 ccpTest\cf0 ::onResolveCCBCCCallFuncSelector(\cf7 CCObject\cf0  * pTarget, \cf5 const\cf0  \cf5 char\cf0 * pSelectorName)\
\{\
    \cf5 return\cf0  \cf5 NULL\cf0 ;\
\}\
SEL_CCControlHandler ccpTest::onResolveCCBCCControlSelector(CCObject * pTarget, \cf5 const\cf0  \cf5 char\cf0 * pSelectorName)\
\{\
    \cf5 return\cf0  \cf5 NULL\cf0 ;\
\}\
\pard\tx770\pardeftab770\pardirnatural
\cf2 //
\f1 \'b0\'f3\'b6\'a8\'cd\'ea\'b3\'c9\'c1\'a2\'bc\'b4\'b5\'f7\'d3\'c3
\f0 \cf0 \
\cf5 void\cf0  \cf7 ccpTest\cf0 ::onNodeLoaded(\cf10 CCNode\cf0  * pNode, \cf7 CCNodeLoader\cf0  * pNodeLoader)\
\{\
    \cf7 myLabel\cf0 ->\cf9 setString\cf0 (\cf4 "AAAAAAAA"\cf0 );\
\}\
\
\cf2 //
\f1 \'c9\'e8\'d6\'c3\'b6\'af\'d7\'f7\'b9\'dc\'c0\'ed\'c6\'f7\'b7\'bd\'b7\'a8
\f0 \cf0 \
\cf5 void\cf0  \cf7 ccpTest\cf0 ::setAnimationmanger(\cf7 CCBAnimationManager\cf0  * pAnimationManager)\
\{\
    \cf9 CCLog\cf0 (\cf4 "setAnimationmanger"\cf0 );\
    \cf3 CC_SAFE_RELEASE_NULL\cf0 (\cf7 animationManager\cf0 );\
    \cf7 animationManager\cf0  = pAnimationManager;\
    \cf3 CC_SAFE_RETAIN\cf0 (\cf7 animationManager\cf0 );\
\}\
\
\cf5 void\cf0  \cf7 ccpTest\cf0 ::menuCloseCallback(\cf10 CCObject\cf0 * pSender)\
\{\
\
    \cf9 CCLog\cf0 (\cf4 "menuCloseCallback"\cf0 );\
    \cf7 animationManager\cf0 ->\cf8 runAnimationsForSequenceNamed\cf0 (\cf4 "fly12"\cf0 );\
\}\
\
/////////////////////////////////////////////JSON
\f1 \'bd\'e2\'ce\'f6
\f0 \
\cf3 #ifndef __HELLOWORLD_SCENE_H__\
#define __HELLOWORLD_SCENE_H__\cf0 \
\cf3 #include \cf4 "cocos2d.h"\cf3 \
#include \cf4 "libjson.h"\cf0 \
\cf5 class\cf0  HelloWorld : \cf5 public\cf0  \cf7 cocos2d\cf0 ::\cf7 CCLayer\cf0 \
\{\
\cf5 public\cf0 :\
    \cf5 virtual\cf0  \cf5 bool\cf0  init();  \
    \cf5 static\cf0  \cf7 cocos2d\cf0 ::\cf7 CCScene\cf0 * scene();\
    \cf5 void\cf0  menuCloseCallback(\cf7 CCObject\cf0 * pSender);\
    \cf3 CREATE_FUNC\cf0 (\cf7 HelloWorld\cf0 );\
    \
    \cf5 void\cf0   ParseJSON(\cf5 const\cf0  \cf7 JSONNode\cf0  & n);\
    \
\};\
\cf3 #endif\
\
#include \cf4 "HelloWorldScene.h"\cf3 \
#include \cf4 <iostream>\cf3 \
USING_NS_CC\cf0 ;\
\cf5 using\cf0  \cf5 namespace\cf0  \cf10 std\cf0 ;\
\
\pard\tx770\pardeftab770\pardirnatural
\cf7 CCScene\cf0 * \cf7 HelloWorld\cf0 ::scene()\
\{\
    \cf7 CCScene\cf0  *scene = \cf7 CCScene\cf0 ::\cf8 create\cf0 ();\
    \cf7 HelloWorld\cf0  *layer = \cf7 HelloWorld\cf0 ::\cf8 create\cf0 ();\
    scene->\cf8 addChild\cf0 (layer);\
    \cf5 return\cf0  scene;\
\}\
\
\pard\tx770\pardeftab770\pardirnatural
\cf2 // init\cf0 \
\cf5 bool\cf0  \cf7 HelloWorld\cf0 ::init()\
\{\
    \cf5 if\cf0  ( !\cf7 CCLayer\cf0 ::\cf8 init\cf0 () )\
    \{\
        \cf5 return\cf0  \cf5 false\cf0 ;\
    \}\
    \
    \cf2 //CCSize visibleSize = CCDirector::sharedDirector()->getVisibleSize();\cf0 \
    \
    \cf2 //
\f1 \'b8\'f1\'ca\'bd\'bb\'af
\f0 \cf0 \
    \cf2 ///*\cf0 \
    \cf7 JSONNode\cf0  n(\cf3 JSON_NODE\cf0 );\
    n.\cf8 push_back\cf0 (\cf7 JSONNode\cf0 (\cf4 "RootA"\cf0 ,\cf4 "Value in parent node"\cf0 ));\
    \
    \cf7 JSONNode\cf0  c(\cf3 JSON_ARRAY\cf0 );\
    c.\cf8 set_name\cf0 (\cf4 "ChildNode"\cf0 );\
    \
    \cf7 JSONNode\cf0  c1(\cf3 JSON_NODE\cf0 ),c2(\cf3 JSON_NODE\cf0 );\
    c1.\cf8 push_back\cf0 (\cf7 JSONNode\cf0 (\cf4 "ChildA"\cf0 ,\cf4 "String Value c1"\cf0 ));\
    c1.\cf8 push_back\cf0 (\cf7 JSONNode\cf0 (\cf4 "ChildB"\cf0 ,\cf4 "dsf c1"\cf0 ));\
    c2.\cf8 push_back\cf0 (\cf7 JSONNode\cf0 (\cf4 "ChildA"\cf0 ,\cf4 "String Value c2"\cf0 ));\
    c2.\cf8 push_back\cf0 (\cf7 JSONNode\cf0 (\cf4 "ChildB"\cf0 ,\cf4 "
\f1 \'d6\'d0\'ce\'c4
\f0 "\cf0 ));\
    \
    c.\cf8 push_back\cf0 (c1);\
    c.\cf8 push_back\cf0 (c2);\
    \
    n.\cf8 push_back\cf0 (c);\
    \
    \cf10 cout\cf0 <<\cf9 endl\cf0 <<n.\cf8 write_formatted\cf0 ()<<\cf9 endl\cf0 <<\cf9 endl\cf0 ;\
    \cf2 //*/\cf0 \
    \cf2 /*\
    JSONNode n(JSON_NODE);\
\
    JSONNode c(JSON_ARRAY);\
    c.set_name("Tollgate");\
    \
    JSONNode c1(JSON_NODE);\
    JSONNode c2(JSON_NODE);\
    \
    JSONNode c11(JSON_NODE);\
    c11.set_name("type1");\
    JSONNode c22(JSON_NODE);\
    c22.set_name("type2");\
    \
    c11.push_back(JSONNode("RefreshTime",0.5));\
    c11.push_back(JSONNode("Count",100));\
\
    c22.push_back(JSONNode("RefreshTime",5));\
    c22.push_back(JSONNode("Count",2));\
    \
    c1.push_back(c11);\
    c2.push_back(c22);\
    \
    c.push_back(c1);\
    c.push_back(c2);\
    \
    n.push_back(c);\
    \
    cout<<endl<<n.write_formatted()<<endl<<endl;\
    */\cf0 \
    \
    \cf2 //JSONNode * m = libjson::parse(const json_string & json);\cf0 \
    \cf8 ParseJSON\cf0 (n);\
    \
    \
    \cf10 std\cf0 ::\cf10 string\cf0  path = \cf7 CCFileUtils\cf0 ::\cf8 sharedFileUtils\cf0 ()->\cf8 getWritablePath\cf0 ();\
    \cf10 std\cf0 ::\cf10 string\cf0  path2 = \cf7 CCFileUtils\cf0 ::\cf8 sharedFileUtils\cf0 ()->\cf8 fullPathForFilename\cf0 (\cf4 "Icon-57.png"\cf0 );\
    \
    \cf8 CCLog\cf0 (\cf4 "%s"\cf0 ,path.\cf9 c_str\cf0 ());\
    \cf8 CCLog\cf0 (\cf4 "%s"\cf0 ,path2.\cf9 c_str\cf0 ());\
    \cf7 CCUserDefault\cf0  * userDefault = \cf7 CCUserDefault\cf0 ::\cf8 sharedUserDefault\cf0 ();\
    \cf5 bool\cf0  firtUsing = userDefault->\cf8 getBoolForKey\cf0 (\cf4 "key6"\cf0 ,\cf5 true\cf0 );\
    \cf5 if\cf0  (firtUsing)\
    \{\
        userDefault->\cf8 setBoolForKey\cf0 (\cf4 "key6"\cf0 ,\cf5 false\cf0 );\
    \}\
    userDefault->\cf8 setStringForKey\cf0 (\cf4 "key1"\cf0 , \cf4 "value1"\cf0 );\
    userDefault->\cf8 setBoolForKey\cf0 (\cf4 "key2"\cf0 , \cf5 true\cf0 );\
    userDefault->\cf8 setDoubleForKey\cf0 (\cf4 "key3"\cf0 , \cf6 12.3\cf0 );\
    userDefault->\cf8 setFloatForKey\cf0 (\cf4 "key4"\cf0 , \cf6 10.0\cf0 );\
    userDefault->\cf8 setIntegerForKey\cf0 (\cf4 "key5"\cf0 , \cf6 1\cf0 );\
    \
    userDefault->\cf8 flush\cf0 ();\
   \
    \cf5 return\cf0  \cf5 true\cf0 ;\
\}\
\
\
\cf5 static\cf0  \cf5 int\cf0  a = \cf6 0\cf0 ;\
\cf2 //JSON
\f1 \'bd\'e2\'ce\'f6
\f0 \cf0 \
\cf5 void\cf0   \cf7 HelloWorld\cf0 ::ParseJSON(\cf5 const\cf0  \cf7 JSONNode\cf0  & n)\
\{\
    \cf7 a\cf0 ++;\
    \cf10 cout\cf0 <<\cf4 "a   : "\cf0 <<\cf7 a\cf0 <<\cf9 endl\cf0 ;\
    \cf7 JSONNode\cf0 ::\cf7 const_iterator\cf0  i = n.\cf8 begin\cf0 ();\
    \cf5 while\cf0  (i != n.\cf8 end\cf0 ())\
    \{\
        \cf5 if\cf0  (i->\cf8 type\cf0 () == \cf3 JSON_ARRAY\cf0     ||    i->\cf8 type\cf0 () == \cf3 JSON_NODE\cf0  )\
        \{\
            \cf8 ParseJSON\cf0 (*i);\
        \}\
        \cf10 std\cf0 ::\cf10 string\cf0  node_name = i->\cf8 name\cf0 ();\
        \cf5 if\cf0  (node_name == \cf4 "RootA"\cf0 )\
        \{\
            \cf7 json_string\cf0  rootA = i->\cf8 as_string\cf0 ();\
            \cf10 cout\cf0 <<rootA<<\cf9 endl\cf0 ;\
        \}\
        \cf5 else\cf0  \cf5 if\cf0  (node_name == \cf4 "ChildA"\cf0 )\
        \{\
            \cf7 json_string\cf0  ChildA = i->\cf8 as_string\cf0 ();\
            \cf10 cout\cf0 <<ChildA<<\cf9 endl\cf0 ;\
        \}\
        \cf5 else\cf0  \cf5 if\cf0  (node_name == \cf4 "ChildB"\cf0 )\
        \{\
            \cf7 json_string\cf0  ChildB = i->\cf8 as_string\cf0 ();\
            \cf2 //const char * a = ChildB.c_str();\cf0 \
            \cf10 cout\cf0 <<ChildB<<\cf9 endl\cf0 ;\
            \cf2 //pLabel->setString(a);\cf0 \
        \}\
        ++i;\
    \}\
\}\
///////////////////////////////////////////
\f1 \'be\'ab\'c1\'e9\'c5\'f6\'d7\'b2
\f0 //////////////////////////////////////\
\cf2 //
\f1 \'c5\'f6\'d7\'b2\'bc\'ec\'b2\'e2
\f0 \cf0 \
\cf5 this\cf0 ->\cf8 schedule\cf0 (\cf3 schedule_selector\cf0 (\cf7 HelloWorld\cf0 ::\cf8 detection\cf0 ), \cf6 0.1\cf0 );\
\cf5 void\cf0  \cf7 HelloWorld\cf0 ::detection()\
\{\
    \cf5 for\cf0  (\cf5 int\cf0  i=\cf6 0\cf0 ; i<\cf7 enemyArray\cf0 ->\cf8 count\cf0 (); ++i)\
    \{\
        \cf7 CCSprite\cf0  * s = (\cf7 CCSprite\cf0  *)\cf7 enemyArray\cf0 ->\cf8 objectAtIndex\cf0 (i);\
        \cf5 if\cf0  (\cf8 iscollision\cf0 (\cf7 _player\cf0 , s))\
        \{\
            \
        \}\
    \}\
    \cf7 CCArray\cf0  * bulletA = \cf7 CCArray\cf0 ::\cf8 create\cf0 ();\
    \cf7 CCArray\cf0  * enemyA = \cf7 CCArray\cf0 ::\cf8 create\cf0 ();\
    \cf5 for\cf0  (\cf5 int\cf0  i=\cf6 0\cf0 ; i<\cf7 bulletArray\cf0 ->\cf8 count\cf0 (); ++i)\
    \{\
        \cf7 CCSprite\cf0  * bullet = (\cf7 CCSprite\cf0  *)\cf7 bulletArray\cf0 ->\cf8 objectAtIndex\cf0 (i);\
        \cf5 for\cf0  (\cf5 int\cf0  j=\cf6 0\cf0 ; j<\cf7 enemyArray\cf0 ->\cf8 count\cf0 (); j++)\
        \{\
            \cf7 CCSprite\cf0  * enemy = (\cf7 CCSprite\cf0 *)\cf7 enemyArray\cf0 ->\cf8 objectAtIndex\cf0 (j);\
            \cf5 if\cf0  (\cf8 iscollision\cf0 (bullet, enemy))\
            \{\
                bullet->\cf8 removeFromParent\cf0 ();\
                enemy->\cf8 removeFromParent\cf0 ();\
                bulletA->\cf8 addObject\cf0 (bullet);\
                enemyA->\cf8 addObject\cf0 (enemy);\
            \}\
        \}\
    \}\
    \cf5 for\cf0  (\cf5 int\cf0  i=\cf6 0\cf0 ; i<bulletA->\cf8 count\cf0 (); ++i)\
    \{\
        \cf7 CCSprite\cf0  * bullet = (\cf7 CCSprite\cf0  *)bulletA->\cf8 objectAtIndex\cf0 (i);\
        \cf7 bulletArray\cf0 ->\cf8 removeObject\cf0 (bullet);\
    \}\
    \cf5 for\cf0  (\cf5 int\cf0  i=\cf6 0\cf0 ; i<enemyA->\cf8 count\cf0 (); ++i)\
    \{\
        \cf7 CCSprite\cf0  * enemy = (\cf7 CCSprite\cf0  *)enemyA->\cf8 objectAtIndex\cf0 (i);\
        \cf7 bulletArray\cf0 ->\cf8 removeObject\cf0 (enemy);\
    \}\
\}\
\cf5 bool\cf0  \cf7 HelloWorld\cf0 ::iscollision(\cf7 CCSprite\cf0  * mySprite,\cf7 CCSprite\cf0  * testsprite)\
\{\
    \cf7 CCRect\cf0  myRect = \cf8 getRect\cf0 (mySprite);\
    \cf7 CCRect\cf0  testRect = \cf8 getRect\cf0 (testsprite);\
    \cf5 return\cf0   myRect.\cf8 intersectsRect\cf0 (testRect);\
    \cf2 /*\
     CCPoint point1 = mysprite->getPosition();\
     CCPoint point2 = testsprite->getPosition();\
     \
     CCSize point1Size =  mysprite->getContentSize();\
     point1Size.width = point1Size.width*(mysprite->getScaleX());\
     point1Size.height = point1Size.height*(mysprite->getScaleY());\
     CCSize point2Size =  testsprite->getContentSize();\
     point2Size.width = point2Size.width*(testsprite->getScaleX());\
     point2Size.height = point2Size.height*(testsprite->getScaleY());\
     \
     if(abs(point1.x-point2.x) <= point1Size.width/2 + point2Size.width/2 &&abs(point1.y-point2.y) <= point1Size.height/2 + point2Size.height/2)\
     return true;\
     return false;\
     */\cf0 \
\}\
\pard\tx770\pardeftab770\pardirnatural
\cf7 CCRect\cf0  \cf7 HelloWorld\cf0 ::getRect(\cf7 CCSprite\cf0  * sprite)\
\{\
    \cf2 //
\f1 \'d5\'e2\'c0\'ef\'c8\'e7\'b9\'fb
\f0 sprite
\f1 \'d3\'d0\'cb\'f5\'b7\'c5\'c1\'cb\'a3\'ac\'bb\'f1\'c8\'a1
\f0 sprite
\f1 \'ca\'c7\'b7\'f1\'d5\'fd\'c8\'b7\'c1\'cb
\f0 \cf0 \
    \cf7 CCSize\cf0  s = sprite->\cf8 getContentSize\cf0 ();\
    \cf7 CCPoint\cf0  p = sprite->\cf8 getPosition\cf0 ();\
    \cf7 CCPoint\cf0  ap = sprite->\cf8 getAnchorPoint\cf0 ();\
    \cf7 CCRect\cf0  rect = \cf3 CCRectMake\cf0 ( p.\cf7 x\cf0  - ap.\cf7 x\cf0  * s.\cf7 width\cf0  , p.\cf7 y\cf0  - ap.\cf7 y\cf0  * s.\cf7 height\cf0 ,                               s.\cf7 width\cf0 , s.\cf7 height\cf0 );\
    \cf5 return\cf0  rect;\
\}\
\
///////////////////////////////////////////
\f1 \'b5\'d8\'cd\'bc
\f0  
\f1 \'cd\'df\'bf\'e9
\f0 //////////////////////////////////////\
\pard\tx770\pardeftab770\pardirnatural
\cf3 #ifndef __HELLOWORLD_SCENE_H__\
#define __HELLOWORLD_SCENE_H__\
\cf0 \
\cf3 #include \cf4 "cocos2d.h"\cf3 \
#include \cf4 "cocos-ext.h"\cf3 \
USING_NS_CC\cf0 ;\
\
\cf5 class\cf0  HelloWorld : \cf5 public\cf0  \cf7 cocos2d\cf0 ::\cf7 CCLayer\cf0 \
\{\
\cf5 public\cf0 :\
    \cf5 virtual\cf0  \cf5 bool\cf0  init();\
    \cf5 static\cf0  \cf7 cocos2d\cf0 ::\cf7 CCScene\cf0 * scene();\
    \cf5 void\cf0  menuCloseCallback(\cf7 CCObject\cf0 * pSender);\
    \cf3 CREATE_FUNC\cf0 (\cf7 HelloWorld\cf0 );\
    \
    \
    \cf5 virtual\cf0  \cf5 bool\cf0  ccTouchBegan(\cf7 CCTouch\cf0  *pTouch, \cf7 CCEvent\cf0  *pEvent) ;\
    \cf5 virtual\cf0  \cf5 void\cf0  ccTouchMoved(\cf7 CCTouch\cf0  *pTouch, \cf7 CCEvent\cf0  *pEvent);\
    \cf5 virtual\cf0  \cf5 void\cf0  ccTouchEnded(\cf7 CCTouch\cf0  *pTouch, \cf7 CCEvent\cf0  *pEvent);\
    \cf5 virtual\cf0  \cf5 void\cf0  ccTouchCancelled(\cf7 CCTouch\cf0  *pTouch, \cf7 CCEvent\cf0  *pEvent);\
    \
    \cf5 bool\cf0  iscollision(\cf7 CCSprite\cf0  * mySprite,\cf7 CCSprite\cf0  * testsprite);\
    \cf7 CCRect\cf0  getRect(\cf7 CCSprite\cf0  * sprite);\
    \cf5 void\cf0  detection();\
    \
\cf5 public\cf0 :\
    \cf7 CCSprite\cf0  * _player ;\
    \cf7 CCTMXTiledMap\cf0  * _tiledMap;\
    \cf7 CCTMXLayer\cf0  * wall, * foreground;\
    \cf7 CCPoint\cf0  mapPoint,heroPoint,beginPoint;\
    \
    \cf5 int\cf0  count;\
    \cf5 bool\cf0  mode;\
    \cf7 CCLabelTTF\cf0  * label;\
    \cf5 void\cf0  goon(\cf7 CCNode\cf0  * pSender);\
    \cf5 void\cf0  toggleGame(\cf7 CCNode\cf0  * pSender);\
    \cf5 void\cf0  targetFinish(\cf7 CCNode\cf0  * pSender);\
    \
    \cf7 CCArray\cf0  * bulletArray;\
    \cf7 CCArray\cf0  * enemyArray;\
    \
\};\
\
\cf3 #endif\
\cf0 \
\
\cf3 #include \cf4 "HelloWorldScene.h"\cf3 \
\cf0 \
\cf3 USING_NS_CC\cf0 ;\
\
\pard\tx770\pardeftab770\pardirnatural
\cf7 CCScene\cf0 * \cf7 HelloWorld\cf0 ::scene()\
\{\
    \cf2 // 'scene' is an autorelease object\cf0 \
    \cf7 CCScene\cf0  *scene = \cf7 CCScene\cf0 ::\cf8 create\cf0 ();\
    \
    \cf2 // 'layer' is an autorelease object\cf0 \
    \cf7 HelloWorld\cf0  *layer = \cf7 HelloWorld\cf0 ::\cf8 create\cf0 ();\
\
    \cf2 // add layer as a child to scene\cf0 \
    scene->\cf8 addChild\cf0 (layer);\
\
    \cf2 // return the scene\cf0 \
    \cf5 return\cf0  scene;\
\}\
\
\pard\tx770\pardeftab770\pardirnatural
\cf2 // on "init" you need to initialize your instance\cf0 \
\cf5 bool\cf0  \cf7 HelloWorld\cf0 ::init()\
\{\
    \cf5 if\cf0  ( !\cf7 CCLayer\cf0 ::\cf8 init\cf0 () )\
    \{\
        \cf5 return\cf0  \cf5 false\cf0 ;\
    \}\
    \
    \cf7 mode\cf0  = \cf5 true\cf0 ;\
    \cf7 CCDirector\cf0 ::\cf8 sharedDirector\cf0 ()->\cf8 getTouchDispatcher\cf0 ()->\cf8 addTargetedDelegate\cf0 (\cf5 this\cf0 , \cf6 0\cf0 , \cf5 false\cf0 );\
    \cf7 count\cf0  = \cf6 0\cf0 ;\
    \
    \
    \cf7 enemyArray\cf0  = \cf7 CCArray\cf0 ::\cf8 create\cf0 ();\
    \
    \cf2 //CCSize visibleSize = CCDirector::sharedDirector()->getVisibleSize();\cf0 \
    \
    \cf7 _tiledMap\cf0  = \cf7 CCTMXTiledMap\cf0 ::\cf8 create\cf0 (\cf4 "tiled.tmx"\cf0 );\
    \cf7 _tiledMap\cf0 ->\cf8 setPosition\cf0 (\cf3 ccp\cf0 (\cf6 0\cf0 ,\cf6 0\cf0 ));\
    \cf8 addChild\cf0 (\cf7 _tiledMap\cf0 );\
    \cf7 wall\cf0  = \cf7 _tiledMap\cf0 ->\cf8 layerNamed\cf0 (\cf4 "wall"\cf0 );\
    \cf7 foreground\cf0  = \cf7 _tiledMap\cf0 ->\cf8 layerNamed\cf0 (\cf4 "foreground"\cf0 );\
    \
    \cf7 CCTMXObjectGroup\cf0  * objects = \cf7 _tiledMap\cf0 ->\cf8 objectGroupNamed\cf0 (\cf4 "hero"\cf0 );\
    \cf7 CCDictionary\cf0  * spawnPoint = objects->\cf8 objectNamed\cf0 (\cf4 "player"\cf0 );\
    \cf7 heroPoint\cf0 .\cf7 x\cf0  = spawnPoint->\cf8 valueForKey\cf0 (\cf4 "x"\cf0 )->\cf8 floatValue\cf0 ();\
    \cf7 heroPoint\cf0 .\cf7 y\cf0  = spawnPoint->\cf8 valueForKey\cf0 (\cf4 "y"\cf0 )->\cf8 floatValue\cf0 ();\
    \cf8 CCLog\cf0 (\cf4 "x:%f y:%f"\cf0 ,\cf7 heroPoint\cf0 .\cf7 x\cf0 ,\cf7 heroPoint\cf0 .\cf7 y\cf0 );\
    \
    \cf7 _player\cf0  = \cf7 CCSprite\cf0 ::\cf8 create\cf0 (\cf4 "www.png"\cf0 );\
    \cf7 _player\cf0 ->\cf8 setAnchorPoint\cf0 (\cf7 CCPoint\cf0 (\cf6 0\cf0 ,\cf6 0\cf0 ));\
    \cf7 _player\cf0 ->\cf8 setPosition\cf0 (\cf7 heroPoint\cf0 );\
    \cf7 _tiledMap\cf0 ->\cf8 addChild\cf0 (\cf7 _player\cf0 ,\cf6 0\cf0 );\
    \
   \
    \cf7 label\cf0  = \cf7 CCLabelTTF\cf0 ::\cf8 create\cf0 (\cf4 "0"\cf0 ,\cf4 "Verdana"\cf0 ,\cf6 20\cf0 );\
    \cf7 label\cf0 ->\cf8 setPosition\cf0 (\cf3 ccp\cf0 (\cf7 CCDirector\cf0 ::\cf8 sharedDirector\cf0 ()->\cf8 getWinSize\cf0 ().\cf7 width\cf0 -\cf7 label\cf0 ->\cf8 getContentSize\cf0 ().\cf7 width\cf0 /\cf6 2\cf0 ,\cf7 label\cf0 ->\cf8 getContentSize\cf0 ().\cf7 height\cf0 /\cf6 2\cf0 ));\
    \cf8 addChild\cf0 (\cf7 label\cf0 ,\cf6 10\cf0 );\
    \cf5 for\cf0 (\cf5 int\cf0  i=\cf6 0\cf0 ;i<\cf5 int\cf0 (objects->\cf8 getObjects\cf0 ()->\cf8 count\cf0 ());i++)\
    \{\
        \cf7 CCDictionary\cf0  * enemy = (\cf7 CCDictionary\cf0  *)objects->\cf8 getObjects\cf0 ()->\cf8 objectAtIndex\cf0 (i);\
        \cf5 if\cf0 (enemy->\cf8 valueForKey\cf0 (\cf4 "n"\cf0 )->\cf8 intValue\cf0 () == \cf6 1\cf0 )\
        \{\
            \cf7 CCSprite\cf0  *s=\cf7 CCSprite\cf0 ::\cf8 create\cf0 (\cf4 "enemy1.png"\cf0 );\
            \cf5 float\cf0  x = enemy->\cf8 valueForKey\cf0 (\cf4 "x"\cf0 )->\cf8 floatValue\cf0 ();\
            \cf5 float\cf0  y = enemy->\cf8 valueForKey\cf0 (\cf4 "y"\cf0 )->\cf8 floatValue\cf0 ();\
            s->\cf8 setPosition\cf0 (\cf3 ccp\cf0 (x,y));\
            s->\cf8 setAnchorPoint\cf0 (\cf7 CCPoint\cf0 (\cf6 0\cf0 ,\cf6 0\cf0 ));\
            \cf7 _tiledMap\cf0 ->\cf8 addChild\cf0 (s,\cf6 4\cf0 );\
            \cf7 enemyArray\cf0 ->\cf8 addObject\cf0 (s);\
            \cf7 CCActionInterval\cf0  *move=\cf7 CCMoveBy\cf0 ::\cf8 create\cf0 (\cf6 0.5\cf0 ,\cf7 CCPoint\cf0 (\cf7 _player\cf0 ->\cf8 getPosition\cf0 ().\cf7 x\cf0 -s->\cf8 getPosition\cf0 ().\cf7 x\cf0 >\cf6 0\cf0 ?\cf6 10\cf0 :-\cf6 10\cf0 ,\cf7 _player\cf0 ->\cf8 getPosition\cf0 ().\cf7 y\cf0 -s->\cf8 getPosition\cf0 ().\cf7 y\cf0 >\cf6 0\cf0 ?\cf6 10\cf0 :-\cf6 10\cf0 ));\
            \cf7 CCFiniteTimeAction\cf0  *func=\cf7 CCCallFuncN\cf0 ::\cf8 create\cf0 (\cf5 this\cf0 ,\cf3 callfuncN_selector\cf0 (\cf7 HelloWorld\cf0 ::\cf8 goon\cf0 ));\
            s->\cf8 runAction\cf0 (\cf7 CCSequence\cf0 ::\cf8 create\cf0 (move,func,\cf5 NULL\cf0 ));\
        \}\
    \}\
    \
    \cf7 CCMenuItem\cf0  * oon,*ooff;\
    oon = \cf7 CCMenuItemImage\cf0 ::\cf8 create\cf0 (\cf4 "projectile-button-on.png"\cf0 ,\cf4 "projectile-button-on.png"\cf0 );\
    ooff = \cf7 CCMenuItemImage\cf0 ::\cf8 create\cf0 (\cf4 "projectile-button-off.png"\cf0 , \cf4 "projectile-button-off.png"\cf0 );\
    \cf7 CCMenuItemToggle\cf0  * toggle = \cf7 CCMenuItemToggle\cf0 ::\cf8 createWithTarget\cf0 (\cf5 this\cf0 , \cf3 menu_selector\cf0 (\cf7 HelloWorld\cf0 ::\cf8 toggleGame\cf0 ), ooff,oon,\cf5 NULL\cf0 );\
    \cf7 CCMenu\cf0  * menu = \cf7 CCMenu\cf0 ::\cf8 create\cf0 (toggle ,\cf5 NULL\cf0 );\
    menu->\cf8 setPosition\cf0 (\cf3 ccp\cf0 (oon->getContentSize().width/\cf6 2\cf0 ,oon->\cf8 getContentSize\cf0 ().\cf7 height\cf0 /\cf6 2\cf0 ));\
    \cf8 addChild\cf0 (menu);\
    \
    \cf2 //bRet = true;\cf0 \
    \
    \cf2 //
\f1 \'c5\'f6\'d7\'b2\'bc\'ec\'b2\'e2
\f0 \cf0 \
    \cf5 this\cf0 ->\cf8 schedule\cf0 (\cf3 schedule_selector\cf0 (\cf7 HelloWorld\cf0 ::\cf8 detection\cf0 ), \cf6 0.1\cf0 );\
    \
    \cf5 return\cf0  \cf5 true\cf0 ;\
\}\
\cf5 void\cf0  \cf7 HelloWorld\cf0 ::detection()\
\{\
    \cf5 for\cf0  (\cf5 int\cf0  i=\cf6 0\cf0 ; i<\cf7 enemyArray\cf0 ->\cf8 count\cf0 (); ++i)\
    \{\
        \cf7 CCSprite\cf0  * s = (\cf7 CCSprite\cf0  *)\cf7 enemyArray\cf0 ->\cf8 objectAtIndex\cf0 (i);\
        \cf5 if\cf0  (\cf8 iscollision\cf0 (\cf7 _player\cf0 , s))\
        \{\
            \
        \}\
    \}\
    \cf7 CCArray\cf0  * bulletA = \cf7 CCArray\cf0 ::\cf8 create\cf0 ();\
    \cf7 CCArray\cf0  * enemyA = \cf7 CCArray\cf0 ::\cf8 create\cf0 ();\
    \cf5 for\cf0  (\cf5 int\cf0  i=\cf6 0\cf0 ; i<\cf7 bulletArray\cf0 ->\cf8 count\cf0 (); ++i)\
    \{\
        \cf7 CCSprite\cf0  * bullet = (\cf7 CCSprite\cf0  *)\cf7 bulletArray\cf0 ->\cf8 objectAtIndex\cf0 (i);\
        \cf5 for\cf0  (\cf5 int\cf0  j=\cf6 0\cf0 ; j<\cf7 enemyArray\cf0 ->\cf8 count\cf0 (); j++)\
        \{\
            \cf7 CCSprite\cf0  * enemy = (\cf7 CCSprite\cf0 *)\cf7 enemyArray\cf0 ->\cf8 objectAtIndex\cf0 (j);\
            \cf5 if\cf0  (\cf8 iscollision\cf0 (bullet, enemy))\
            \{\
                bullet->\cf8 removeFromParent\cf0 ();\
                enemy->\cf8 removeFromParent\cf0 ();\
                bulletA->\cf8 addObject\cf0 (bullet);\
                enemyA->\cf8 addObject\cf0 (enemy);\
            \}\
        \}\
    \}\
    \cf5 for\cf0  (\cf5 int\cf0  i=\cf6 0\cf0 ; i<bulletA->\cf8 count\cf0 (); ++i)\
    \{\
        \cf7 CCSprite\cf0  * bullet = (\cf7 CCSprite\cf0  *)bulletA->\cf8 objectAtIndex\cf0 (i);\
        \cf7 bulletArray\cf0 ->\cf8 removeObject\cf0 (bullet);\
    \}\
    \cf5 for\cf0  (\cf5 int\cf0  i=\cf6 0\cf0 ; i<enemyA->\cf8 count\cf0 (); ++i)\
    \{\
        \cf7 CCSprite\cf0  * enemy = (\cf7 CCSprite\cf0  *)enemyA->\cf8 objectAtIndex\cf0 (i);\
        \cf7 bulletArray\cf0 ->\cf8 removeObject\cf0 (enemy);\
    \}\
\}\
\pard\tx770\pardeftab770\pardirnatural

\f1 \cf0 //\'c5\'f6\'d7\'b2\'bc\'ec\'b2\'e2
\f0 \
\pard\tx770\pardeftab770\pardirnatural
\cf5 bool\cf0  \cf7 HelloWorld\cf0 ::iscollision(\cf7 CCSprite\cf0  * mySprite,\cf7 CCSprite\cf0  * testsprite)\
\{\
    \cf7 CCRect\cf0  myRect = mySprite->\cf8 boundingBox\cf0 ();\
    \cf7 CCRect\cf0  testRect = testsprite->\cf8 boundingBox\cf0 ();\
    \cf5 return\cf0   myRect.\cf8 intersectsRect\cf0 (testRect);\
\
\
\
    //\cf7 CCRect\cf0  myRect = \cf8 getRect\cf0 (mySprite);\
    //\cf7 CCRect\cf0  testRect = \cf8 getRect\cf0 (testsprite);\
    //\cf5 return\cf0   myRect.\cf8 intersectsRect\cf0 (testRect);\
    \cf2 /*\
     CCPoint point1 = mysprite->getPosition();\
     CCPoint point2 = testsprite->getPosition();\
     \
     CCSize point1Size =  mysprite->getContentSize();\
     point1Size.width = point1Size.width*(mysprite->getScaleX());\
     point1Size.height = point1Size.height*(mysprite->getScaleY());\
     CCSize point2Size =  testsprite->getContentSize();\
     point2Size.width = point2Size.width*(testsprite->getScaleX());\
     point2Size.height = point2Size.height*(testsprite->getScaleY());\
     \
     if(abs(point1.x-point2.x) <= point1Size.width/2 + point2Size.width/2 &&abs(point1.y-point2.y) <= point1Size.height/2 + point2Size.height/2)\
     return true;\
     return false;\
     */\cf0 \
\}\
\pard\tx770\pardeftab770\pardirnatural
\cf7 CCRect\cf0  \cf7 HelloWorld\cf0 ::getRect(\cf7 CCSprite\cf0  * sprite)\
\{\
    \
\}\
\pard\tx770\pardeftab770\pardirnatural

\f1 \cf0 //button\'ca\'c2\'bc\'fe\'a3\'ac\'d7\'aa\'bb\'bb\'c4\'a3\'ca\'bd\'a3\'a8\'c9\'e4\'bb\'f7\'a3\'ac\'d2\'c6\'b6\'af\'a3\'a9
\f0 \
\pard\tx770\pardeftab770\pardirnatural
\cf5 void\cf0  \cf7 HelloWorld\cf0 ::toggleGame(\cf7 CCNode\cf0  * pSender)\
\{\
    \cf8 CCLog\cf0 (\cf4 "toggleGame"\cf0 );\
    \cf7 mode\cf0  = \cf7 mode\cf0 ?\cf5 false\cf0 :\cf5 true\cf0 ;\
    \
\}\
\cf5 void\cf0  \cf7 HelloWorld\cf0 ::targetFinish(\cf7 CCNode\cf0  * pSender)\
\{\
    \
\}\
\cf5 void\cf0  \cf7 HelloWorld\cf0 ::goon(\cf7 CCNode\cf0  * pSender)\
\{\
    \cf2 //CCLog("goon");\cf0 \
    \cf7 CCSprite\cf0  * s = (\cf7 CCSprite\cf0  *)pSender;\
    \cf7 CCActionInterval\cf0  * move = \cf7 CCMoveBy\cf0 ::\cf8 create\cf0 (\cf6 0.5\cf0 , \cf7 CCPoint\cf0 (\cf7 _player\cf0 ->\cf8 getPosition\cf0 ().\cf7 x\cf0 -s->\cf8 getPosition\cf0 ().\cf7 x\cf0 >\cf6 0\cf0 ?\cf6 10\cf0 :-\cf6 10\cf0 ,\cf7 _player\cf0 ->\cf8 getPosition\cf0 ().\cf7 y\cf0 -s->\cf8 getPosition\cf0 ().\cf7 y\cf0 >\cf6 0\cf0 ?\cf6 10\cf0 :-\cf6 10\cf0 ));\
    \cf7 CCFiniteTimeAction\cf0  * func = \cf7 CCCallFuncN\cf0 ::\cf8 create\cf0 (\cf5 this\cf0 , \cf3 callfuncN_selector\cf0 (\cf7 HelloWorld\cf0 ::\cf8 goon\cf0 ));\
    s->\cf8 runAction\cf0 (\cf7 CCSequence\cf0 ::\cf8 create\cf0 (move,func,\cf5 NULL\cf0 ));\
\}\
\
\cf5 bool\cf0  \cf7 HelloWorld\cf0 ::ccTouchBegan(\cf7 CCTouch\cf0  *pTouch, \cf7 CCEvent\cf0  *pEvent)\
\{\
    \cf2 //CCLog("ccTouchBegan");\cf0 \
    \cf7 beginPoint\cf0  = pTouch->\cf8 getLocation\cf0 ();\
    \cf5 return\cf0  \cf5 true\cf0 ;\
\}\
\cf5 void\cf0  \cf7 HelloWorld\cf0 ::ccTouchMoved(\cf7 CCTouch\cf0  *pTouch, \cf7 CCEvent\cf0  *pEvent)\
\{\
    \cf2 //CCLog("ccTouchMoved");\cf0 \
    \cf5 if\cf0 (\cf7 mode\cf0 )\
    \{\
        \
        \cf7 CCPoint\cf0  pp = pTouch->\cf8 getPreviousLocation\cf0 ();\
        \cf7 CCPoint\cf0  np = pTouch->\cf8 getLocation\cf0 ();\
        \cf7 CCPoint\cf0  dp = \cf8 ccpSub\cf0 (np, pp);\
        \cf5 if\cf0  (\cf7 _tiledMap\cf0 ->\cf8 getPosition\cf0 ().\cf7 x\cf0 +dp.\cf7 x\cf0  > -\cf6 480\cf0  && \cf7 _tiledMap\cf0 ->\cf8 getPosition\cf0 ().\cf7 x\cf0 +dp.\cf7 x\cf0 <\cf6 0\cf0 )\
        \{\
            \cf7 mapPoint\cf0  = \cf3 ccp\cf0 (_tiledMap->getPosition().x+dp.x,\cf6 0\cf0 );\
            \cf7 _tiledMap\cf0 ->\cf8 setPosition\cf0 (\cf7 mapPoint\cf0 );\
        \}\
    \}\
\}\
\cf5 void\cf0  \cf7 HelloWorld\cf0 ::ccTouchEnded(\cf7 CCTouch\cf0  *pTouch, \cf7 CCEvent\cf0  *pEvent)\
\{\
    \
    \cf7 CCPoint\cf0  pp = pTouch->\cf8 getLocation\cf0 ();\
    \cf2 //
\f1 \'ca\'c7\'b7\'f1\'b4\'a6\'d3\'da\'bf\'c9\'d2\'c6\'b6\'af\'d7\'b4\'cc\'ac
\f0 \cf0 \
    \cf5 if\cf0  (\cf7 mode\cf0 )\
    \{\
        \cf2 //
\f1 \'c5\'d0\'b6\'cf\'b4\'a5\'c3\'fe\'b5\'e3\'ce\'bb\'d6\'c3\'ca\'c7\'b7\'f1\'b8\'c4\'b1\'e4
\f0 \cf0 \
        \cf5 if\cf0  (\cf7 beginPoint\cf0 .\cf7 x\cf0  == pp.\cf7 x\cf0  && \cf7 beginPoint\cf0 .\cf7 y\cf0  == pp.\cf7 y\cf0 )\
        \{\
            \cf2 //
\f1 \'d3\'a2\'d0\'db\'b5\'c4\'ce\'bb\'d6\'c3
\f0 \cf0 \
            \cf7 CCPoint\cf0  pt = \cf7 _player\cf0 ->\cf8 getPosition\cf0 ();\
            \
            \cf2 //x
\f1 \'d6\'e1\'b4\'f3\'d3\'da
\f0 y
\f1 \'d6\'e1\'a3\'ac\'cb\'ae\'c6\'bd\'b7\'bd\'cf\'f2\'d2\'c6\'b6\'af
\f0 \cf0 \
            \cf5 if\cf0  (\cf9 fabs\cf0 (pt.\cf7 x\cf0  - (pp.\cf7 x\cf0  - \cf7 mapPoint\cf0 .\cf7 x\cf0 ))>= \cf9 fabs\cf0 (pt.\cf7 y\cf0  - (pp.\cf7 y\cf0  - \cf7 mapPoint\cf0 .\cf7 y\cf0 )))\
            \{\
                \cf2 //
\f1 \'d3\'a2\'d0\'db\'d4\'da\'b4\'a5\'c3\'fe\'b5\'e3\'b5\'c4\'d3\'d2\'b2\'e0
\f0 \cf0 \
                \cf5 if\cf0 (pt.\cf7 x\cf0  >= pp.\cf7 x\cf0 -\cf7 mapPoint\cf0 .\cf7 x\cf0 )\
                \{\
                    \cf2 //
\f1 \'cd\'df\'bf\'e9\'a3\'ac\'d7\'f3\'c9\'cf\'bd\'c7\'ce\'aa\'a3\'a8
\f0 0
\f1 \'a3\'ac
\f0 0
\f1 \'a3\'a9\'a3\'ac\'cf\'f2\'d3\'d2
\f0 x
\f1 \'bc\'d3\'d2\'bb\'a3\'ac\'cf\'f2\'cf\'c2
\f0 y
\f1 \'bc\'d3\'d2\'bb
\f0 /*
\f1 \'c5\'d0\'b6\'cf\'d3\'a2\'d0\'db\'c8\'e7\'b9\'fb\'cf\'e0\'d7\'f3\'d2\'c6\'b6\'af\'d2\'bb\'b2\'bd\'a3\'ac\'cb\'fc\'b5\'c4\'ce\'bb\'d6\'c3\'ca\'c7\'b7\'f1\'c8\'d4\'c8\'bb\'d4\'da\'b5\'d8\'cd\'bc\'c4\'da\'b2\'bf
\f0 */\cf0 \
                    \cf5 if\cf0 ( \cf6 9\cf0 -\cf7 _player\cf0 ->\cf8 getPosition\cf0 ().\cf7 y\cf0 /\cf6 32\cf0 <\cf6 10\cf0    &&   \cf6 9\cf0 -\cf7 _player\cf0 ->\cf8 getPosition\cf0 ().\cf7 y\cf0 /\cf6 32\cf0 >=\cf6 0\cf0     &&   \cf7 _player\cf0 ->\cf8 getPosition\cf0 ().\cf7 x\cf0 /\cf6 32\cf0 -\cf6 1\cf0 <\cf6 30\cf0    &&   \cf7 _player\cf0 ->\cf8 getPosition\cf0 ().\cf7 x\cf0 /\cf6 32\cf0 -\cf6 1\cf0 >=\cf6 0\cf0  && !(\cf7 wall\cf0 ->\cf8 tileGIDAt\cf0 (\cf3 ccp\cf0 (_player->getPosition().x/\cf6 32\cf0 -\cf6 1\cf0 ,\cf6 9\cf0 -\cf7 _player\cf0 ->\cf8 getPosition\cf0 ().\cf7 y\cf0 /\cf6 32\cf0 )))   )\
                    \cf2 //
\f1 \'c5\'d0\'b6\'cf\'ca\'c7\'b7\'f1\'ca\'c7\'b5\'d8\'cd\'bc\'cd\'e2\'c3\'e6\'a3\'ac\'bb\'f2\'d5\'df\'ca\'c7\'b2\'bb\'ca\'c7\'c7\'bd
\f0 \cf0 \
                    \{\
                        \cf8 CCLog\cf0 (\cf4 "ccTouchEnded"\cf0 );\
                        \cf2 //
\f1 \'d3\'a2\'d0\'db\'cf\'e0\'d7\'f3\'d2\'c6\'b6\'af
\f0 32\cf0 \
                        \cf7 _player\cf0 ->\cf8 setPosition\cf0 (\cf3 ccp\cf0 (_player->getPosition().x-\cf6 32\cf0 ,\cf7 _player\cf0 ->\cf8 getPosition\cf0 ().\cf7 y\cf0 ));\
                        \
                        \cf2 //
\f1 \'ca\'c7\'b7\'f1\'d3\'d0\'ce\'f7\'b9\'cf
\f0 \cf0 \
                        \cf5 if\cf0 ( \cf7 foreground\cf0 ->\cf8 tileGIDAt\cf0 (\cf3 ccp\cf0 (_player->getPosition().x/\cf6 32\cf0 ,\cf6 9\cf0 -\cf7 _player\cf0 ->\cf8 getPosition\cf0 ().\cf7 y\cf0 /\cf6 32\cf0 )) )\
                        \{\
                            \cf2 //
\f1 \'d2\'c6\'b3\'fd\'ce\'f7\'b9\'cf
\f0 \cf0 \
                            \cf7 foreground\cf0 ->\cf8 removeTileAt\cf0 (\cf3 ccp\cf0 (_player->getPosition().x/\cf6 32\cf0 ,\cf6 9\cf0 -\cf7 _player\cf0 ->\cf8 getPosition\cf0 ().\cf7 y\cf0 /\cf6 32\cf0 ));\
                            \cf7 count\cf0 ++;\
                            \cf7 CCString\cf0  *temp=\cf7 CCString\cf0 ::\cf8 createWithFormat\cf0 (\cf4 "%d"\cf0 ,\cf7 count\cf0 );\
                            \cf7 label\cf0 ->\cf8 setString\cf0 (temp->\cf8 getCString\cf0 ());\
                        \}\
                    \}\
                    \
                \}\
                \cf5 else\cf0 \
                \{\
                    \cf5 if\cf0 (\cf6 9\cf0 -\cf7 _player\cf0 ->\cf8 getPosition\cf0 ().\cf7 y\cf0 /\cf6 32\cf0 <\cf6 10\cf0 &&\cf6 9\cf0 -\cf7 _player\cf0 ->\cf8 getPosition\cf0 ().\cf7 y\cf0 /\cf6 32\cf0 >=\cf6 0\cf0 &&\cf7 _player\cf0 ->\cf8 getPosition\cf0 ().\cf7 x\cf0 /\cf6 32\cf0 +\cf6 1\cf0 <\cf6 30\cf0 &&\cf7 _player\cf0 ->\cf8 getPosition\cf0 ().\cf7 x\cf0 /\cf6 32\cf0 +\cf6 1\cf0 >=\cf6 0\cf0 &&!(\cf7 wall\cf0 ->\cf8 tileGIDAt\cf0 (\cf3 ccp\cf0 (_player->getPosition().x/\cf6 32\cf0 +\cf6 1\cf0 ,\cf6 9\cf0 -\cf7 _player\cf0 ->\cf8 getPosition\cf0 ().\cf7 y\cf0 /\cf6 32\cf0 ))))\
                    \{\
                        \cf7 _player\cf0 ->\cf8 setPosition\cf0 (\cf3 ccp\cf0 (_player->getPosition().x+\cf6 32\cf0 ,\cf7 _player\cf0 ->\cf8 getPosition\cf0 ().\cf7 y\cf0 ));\
                        \cf5 if\cf0 (\cf7 foreground\cf0 ->\cf8 tileGIDAt\cf0 (\cf3 ccp\cf0 (_player->getPosition().x/\cf6 32\cf0 ,\cf6 9\cf0 -\cf7 _player\cf0 ->\cf8 getPosition\cf0 ().\cf7 y\cf0 /\cf6 32\cf0 )))\
                        \{\
                            \cf7 foreground\cf0 ->\cf8 removeTileAt\cf0 (\cf3 ccp\cf0 (_player->getPosition().x/\cf6 32\cf0 ,\cf6 9\cf0 -\cf7 _player\cf0 ->\cf8 getPosition\cf0 ().\cf7 y\cf0 /\cf6 32\cf0 ));\
							\cf7 count\cf0 ++;\
                            \cf7 CCString\cf0  *temp=\cf7 CCString\cf0 ::\cf8 createWithFormat\cf0 (\cf4 "%d"\cf0 ,\cf7 count\cf0 );\
                            \cf7 label\cf0 ->\cf8 setString\cf0 (temp->\cf8 getCString\cf0 ());\
                        \}\
                    \}\
                    \
                \}\
            \}\
            \cf2 //
\f1 \'ca\'fa\'d6\'b1\'b7\'bd\'cf\'f2\'d2\'c6\'b6\'af
\f0 \cf0 \
            \cf5 else\cf0 \
            \{\
                \cf5 if\cf0 (pt.\cf7 y\cf0 >=pp.\cf7 y\cf0 -\cf7 mapPoint\cf0 .\cf7 y\cf0 )\
                \{\
                    \cf5 if\cf0 (\cf6 9\cf0 -\cf7 _player\cf0 ->\cf8 getPosition\cf0 ().\cf7 y\cf0 /\cf6 32\cf0 +\cf6 1\cf0 <\cf6 10\cf0 &&\cf6 9\cf0 -\cf7 _player\cf0 ->\cf8 getPosition\cf0 ().\cf7 y\cf0 /\cf6 32\cf0 +\cf6 1\cf0 >=\cf6 0\cf0 &&\cf7 _player\cf0 ->\cf8 getPosition\cf0 ().\cf7 x\cf0 /\cf6 32\cf0 <\cf6 50\cf0 &&\cf7 _player\cf0 ->\cf8 getPosition\cf0 ().\cf7 x\cf0 /\cf6 32\cf0 >=\cf6 0\cf0 &&!(\cf7 wall\cf0 ->\cf8 tileGIDAt\cf0 (\cf3 ccp\cf0 (_player->getPosition().x/\cf6 32\cf0 ,\cf6 9\cf0 -\cf7 _player\cf0 ->\cf8 getPosition\cf0 ().\cf7 y\cf0 /\cf6 32\cf0 +\cf6 1\cf0 ))))\
                    \{\
                        \cf7 _player\cf0 ->\cf8 setPosition\cf0 (\cf3 ccp\cf0 (_player->getPosition().x,\cf7 _player\cf0 ->\cf8 getPosition\cf0 ().\cf7 y\cf0 -\cf6 32\cf0 ));\
                        \cf5 if\cf0 (\cf7 foreground\cf0 ->\cf8 tileGIDAt\cf0 (\cf3 ccp\cf0 (_player->getPosition().x/\cf6 32\cf0 ,\cf6 9\cf0 -\cf7 _player\cf0 ->\cf8 getPosition\cf0 ().\cf7 y\cf0 /\cf6 32\cf0 )))\
                        \{\
                            \cf7 foreground\cf0 ->\cf8 removeTileAt\cf0 (\cf3 ccp\cf0 (_player->getPosition().x/\cf6 32\cf0 ,\cf6 9\cf0 -\cf7 _player\cf0 ->\cf8 getPosition\cf0 ().\cf7 y\cf0 /\cf6 32\cf0 ));\
                            \cf7 count\cf0 ++;\
                            \cf7 CCString\cf0  *temp=\cf7 CCString\cf0 ::\cf8 createWithFormat\cf0 (\cf4 "%d"\cf0 ,\cf7 count\cf0 );\
                            \cf7 label\cf0 ->\cf8 setString\cf0 (temp->\cf8 getCString\cf0 ());\
                        \}\
                    \}\
                    \
                    \
                \}\
                \cf5 else\cf0 \
                \{\
                    \cf5 if\cf0 (\cf6 9\cf0 -\cf7 _player\cf0 ->\cf8 getPosition\cf0 ().\cf7 y\cf0 /\cf6 32\cf0 -\cf6 1\cf0 <\cf6 10\cf0 &&\cf6 9\cf0 -\cf7 _player\cf0 ->\cf8 getPosition\cf0 ().\cf7 y\cf0 /\cf6 32\cf0 -\cf6 1\cf0 >=\cf6 0\cf0 &&\cf7 _player\cf0 ->\cf8 getPosition\cf0 ().\cf7 x\cf0 /\cf6 32\cf0 <\cf6 50\cf0 &&\cf7 _player\cf0 ->\cf8 getPosition\cf0 ().\cf7 x\cf0 /\cf6 32\cf0 >=\cf6 0\cf0 &&!(\cf7 wall\cf0 ->\cf8 tileGIDAt\cf0 (\cf3 ccp\cf0 (_player->getPosition().x/\cf6 32\cf0 ,\cf6 9\cf0 -\cf7 _player\cf0 ->\cf8 getPosition\cf0 ().\cf7 y\cf0 /\cf6 32\cf0 -\cf6 1\cf0 ))))\
                    \{\
                        \cf7 _player\cf0 ->\cf8 setPosition\cf0 (\cf3 ccp\cf0 (_player->getPosition().x,\cf7 _player\cf0 ->\cf8 getPosition\cf0 ().\cf7 y\cf0 +\cf6 32\cf0 ));\
                        \cf5 if\cf0 (\cf7 foreground\cf0 ->\cf8 tileGIDAt\cf0 (\cf3 ccp\cf0 (_player->getPosition().x/\cf6 32\cf0 ,\cf6 9\cf0 -\cf7 _player\cf0 ->\cf8 getPosition\cf0 ().\cf7 y\cf0 /\cf6 32\cf0 )))\
                        \{\
                            \cf7 foreground\cf0 ->\cf8 removeTileAt\cf0 (\cf3 ccp\cf0 (_player->getPosition().x/\cf6 32\cf0 ,\cf6 9\cf0 -\cf7 _player\cf0 ->\cf8 getPosition\cf0 ().\cf7 y\cf0 /\cf6 32\cf0 ));\
                            \cf7 count\cf0 ++;\
                            \
                            \cf7 CCString\cf0  *temp=\cf7 CCString\cf0 ::\cf8 createWithFormat\cf0 (\cf4 "%d"\cf0 ,\cf7 count\cf0 );\
                            \cf7 label\cf0 ->\cf8 setString\cf0 (temp->\cf8 getCString\cf0 ());\
                        \}\
                    \}\
                    \
                \}\
            \}\
        \}\
        \
        \
    \}\
    \cf5 else\cf0 \
    \{\
		\cf7 CCSprite\cf0  *s=\cf7 CCSprite\cf0 ::\cf8 create\cf0 (\cf4 "Projectile.png"\cf0 );\
		s->\cf8 setPosition\cf0 (\cf7 _player\cf0 ->\cf8 getPosition\cf0 ());\
		\cf7 _tiledMap\cf0 ->\cf8 addChild\cf0 (s,\cf6 4\cf0 );\
        \cf7 bulletArray\cf0  = \cf7 CCArray\cf0 ::\cf8 create\cf0 ();\
        \cf7 bulletArray\cf0 ->\cf8 addObject\cf0 (s);\
		\cf5 float\cf0  dx=pp.\cf7 x\cf0 -\cf7 _player\cf0 ->\cf8 getPosition\cf0 ().\cf7 x\cf0 ;\
		\cf5 float\cf0  dy=pp.\cf7 y\cf0 -\cf7 _player\cf0 ->\cf8 getPosition\cf0 ().\cf7 y\cf0 ;\
		\cf5 if\cf0 (dx>\cf6 0\cf0 )\
		\{\
			\cf5 float\cf0  lx=\cf6 32\cf0 *\cf6 30\cf0 -\cf7 _player\cf0 ->\cf8 getPosition\cf0 ().\cf7 x\cf0 ;\
			\cf5 float\cf0  ly=dy/dx*lx;\
			\cf7 CCActionInterval\cf0  *move=\cf7 CCMoveBy\cf0 ::\cf8 create\cf0 (\cf6 3\cf0 ,\cf3 ccp\cf0 (lx+s->getContentSize().width,ly));\
			\cf7 CCFiniteTimeAction\cf0  *ff=\cf7 CCCallFuncN\cf0 ::\cf8 create\cf0 (\cf5 this\cf0 ,\cf3 callfuncN_selector\cf0 (\cf7 HelloWorld\cf0 ::\cf8 targetFinish\cf0 ));\
			s->\cf8 runAction\cf0 (\cf7 CCSequence\cf0 ::\cf8 create\cf0 (move,ff,\cf5 NULL\cf0 ));\
		\}\
		\cf5 else\cf0 \
		\{\
			\cf5 float\cf0  lx=\cf6 0\cf0 -\cf7 _player\cf0 ->\cf8 getPosition\cf0 ().\cf7 x\cf0 ;\
			\cf5 float\cf0  ly=dy/dx*lx;\
			\cf7 CCActionInterval\cf0  *move=\cf7 CCMoveBy\cf0 ::\cf8 create\cf0 (\cf6 3\cf0 ,\cf3 ccp\cf0 (lx-s->getContentSize().width,ly));\
			\cf7 CCFiniteTimeAction\cf0  *ff=\cf7 CCCallFuncN\cf0 ::\cf8 create\cf0 (\cf5 this\cf0 ,\cf3 callfuncN_selector\cf0 (\cf7 HelloWorld\cf0 ::\cf8 targetFinish\cf0 ));\
			s->\cf8 runAction\cf0 (\cf7 CCSequence\cf0 ::\cf8 create\cf0 (move,ff,\cf5 NULL\cf0 ));\
		\}\
	\}\
\}\
\
\cf5 void\cf0  \cf7 HelloWorld\cf0 ::ccTouchCancelled(\cf7 CCTouch\cf0  *pTouch, \cf7 CCEvent\cf0  *pEvent)\
\{\
    \
\}\
\cf5 void\cf0  \cf7 HelloWorld\cf0 ::menuCloseCallback(\cf7 CCObject\cf0 * pSender)\
\{\
\
\}\
/////////////////////////////////
\f1 \'a1\'a2\'a1\'a2\'a1\'a2\'a1\'a2\'a1\'a2\'a1\'a2\'a1\'a2\'a1\'a2\'a1\'a2\'a1\'a2\'a1\'a2\'a1\'a2\'a1\'a2\'a1\'a2\'a1\'a2\'a1\'a2
\f0 ///////
\f1 \'ce\'ef\'c0\'ed\'d2\'fd\'c7\'e6\

\f0 \cf3 #ifndef __HELLOWORLD_SCENE_H__\
#define __HELLOWORLD_SCENE_H__\
\cf0 \
\cf3 #include \cf4 "cocos2d.h"\cf3 \
#include \cf4 "Box2D.h"\cf3 \
USING_NS_CC\cf0 ;\
\
\cf5 class\cf0  HelloWorld : \cf5 public\cf0  \cf7 cocos2d\cf0 ::\cf7 CCLayer\cf0 \
\{\
\cf5 public\cf0 :\
    \cf5 virtual\cf0  \cf5 bool\cf0  init();\
    \cf5 static\cf0  \cf7 cocos2d\cf0 ::\cf7 CCScene\cf0 * scene();\
    \cf5 void\cf0  menuCloseCallback(\cf7 CCObject\cf0 * pSender);\
    \cf3 CREATE_FUNC\cf0 (\cf7 HelloWorld\cf0 );\
    \
    \cf5 virtual\cf0  \cf5 bool\cf0  ccTouchBegan(\cf7 CCTouch\cf0  *pTouch, \cf7 CCEvent\cf0  *pEvent);\
    \cf5 virtual\cf0  \cf5 void\cf0  ccTouchMoved(\cf7 CCTouch\cf0  *pTouch, \cf7 CCEvent\cf0  *pEvent);\
    \cf5 virtual\cf0  \cf5 void\cf0  ccTouchEnded(\cf7 CCTouch\cf0  *pTouch, \cf7 CCEvent\cf0  *pEvent);\
    \cf5 virtual\cf0  \cf5 void\cf0  ccTouchCancelled(\cf7 CCTouch\cf0  *pTouch, \cf7 CCEvent\cf0  *pEvent);\
    \
    \cf5 void\cf0  update(\cf5 float\cf0  dt);\
    \cf5 void\cf0  initPhysical();\
    \cf5 void\cf0  addNewSpriteAtPosition(\cf7 CCPoint\cf0  position);\
    \
\cf5 private\cf0 :\
    \cf7 b2World\cf0  * world;\
    \
\};\
\
\cf3 #endif \
\cf0 \
\cf3 #include \cf4 "HelloWorldScene.h"\cf3 \
#include \cf4 "PhysicsSprite.h"\cf3 \
#include \cf4 "MyContactListener.h"\cf3 \
USING_NS_CC\cf0 ;\
\
\pard\tx770\pardeftab770\pardirnatural
\cf7 CCScene\cf0 * \cf7 HelloWorld\cf0 ::scene()\
\{\
    \cf7 CCScene\cf0  *scene = \cf7 CCScene\cf0 ::\cf8 create\cf0 ();\
    \cf7 HelloWorld\cf0  *layer = \cf7 HelloWorld\cf0 ::\cf8 create\cf0 ();\
    scene->\cf8 addChild\cf0 (layer);\
    \cf5 return\cf0  scene;\
\}\
\pard\tx770\pardeftab770\pardirnatural
\cf5 bool\cf0  \cf7 HelloWorld\cf0 ::init()\
\{\
    \cf5 if\cf0  ( !\cf7 CCLayer\cf0 ::\cf8 init\cf0 () )\
    \{\
        \cf5 return\cf0  \cf5 false\cf0 ;\
    \}\
    \
    \cf5 this\cf0 ->\cf8 initPhysical\cf0 ();\
    \cf7 MyContactListener\cf0  *listener = \cf5 new\cf0  \cf7 MyContactListener\cf0 (\cf7 world\cf0 ,\cf5 this\cf0 );\
    \cf7 world\cf0 ->\cf8 SetContactListener\cf0 (listener);\
\
    \
    \cf5 this\cf0 ->\cf8 scheduleUpdate\cf0 ();\
    \
\
    \cf7 CCDirector\cf0 ::\cf8 sharedDirector\cf0 ()->\cf8 getTouchDispatcher\cf0 ()->\cf8 addTargetedDelegate\cf0 (\cf5 this\cf0 ,\cf6 1\cf0 ,\cf5 false\cf0 );\
    \
    \cf5 return\cf0  \cf5 true\cf0 ;\
\}\
\
\cf5 bool\cf0  \cf7 HelloWorld\cf0 ::ccTouchBegan(\cf7 CCTouch\cf0  *pTouch, \cf7 CCEvent\cf0  *pEvent)\
\{\
    \cf5 return\cf0  \cf5 true\cf0 ;\
\}\
\cf5 void\cf0  \cf7 HelloWorld\cf0 ::ccTouchMoved(\cf7 CCTouch\cf0  *pTouch, \cf7 CCEvent\cf0  *pEvent)\
\{\
    \
\}\
\cf5 void\cf0  \cf7 HelloWorld\cf0 ::ccTouchEnded(\cf7 CCTouch\cf0  *pTouch, \cf7 CCEvent\cf0  *pEvent)\
\{\
    \cf8 addNewSpriteAtPosition\cf0 (pTouch->\cf8 getLocation\cf0 ());\
\}\
\cf5 void\cf0  \cf7 HelloWorld\cf0 ::ccTouchCancelled(\cf7 CCTouch\cf0  *pTouch, \cf7 CCEvent\cf0  *pEvent)\
\{\
    \
\}\
\
\cf5 void\cf0  \cf7 HelloWorld\cf0 ::update(\cf5 float\cf0  dt)\
\{\
    \cf5 int\cf0  velocityIterations = \cf6 8\cf0 ;\
    \cf5 int\cf0  positionIterations = \cf6 1\cf0 ;\
    \cf7 world\cf0 ->\cf8 Step\cf0 (dt, velocityIterations, positionIterations);\
    \cf7 b2Body\cf0  * b = \cf7 world\cf0 ->\cf8 GetBodyList\cf0 ();\
    \cf5 while\cf0  (b)\
    \{\
        \cf7 b2Body\cf0  * p = b;\
        b = b->\cf8 GetNext\cf0 ();\
        \cf5 if\cf0  (p->\cf8 GetUserData\cf0 () != \cf5 NULL\cf0 )\
        \{\
            \cf7 PhysicsSprite\cf0 * myActor = (\cf7 PhysicsSprite\cf0 *)p->\cf8 GetUserData\cf0 ();\
            \cf5 if\cf0 (myActor->\cf7 hp\cf0 <\cf6 0\cf0 )\
            \{\
                myActor->\cf8 removeFromParent\cf0 ();\
                \cf7 world\cf0 ->\cf8 DestroyBody\cf0 (p);\
            \}\
            myActor->\cf8 setPosition\cf0 ( \cf3 CCPointMake\cf0 ( b->\cf8 GetPosition\cf0 ().\cf7 x\cf0  * \cf6 32\cf0 , b->\cf8 GetPosition\cf0 ().\cf7 y\cf0  * \cf6 32\cf0 ) );\
            \cf2 //CC_RADIANS_TO_DEGREES 
\f1 \'bb\'a1\'b6\'c8\'b5\'bd\'bd\'c7\'b6\'c8
\f0 \cf0 \
            myActor->\cf8 setRotation\cf0 (-\cf6 1\cf0 *\cf3 CC_RADIANS_TO_DEGREES\cf0 (b->\cf8 GetAngle\cf0 ()) );\
        \}\
    \}\
\
\}\
\cf5 void\cf0  \cf7 HelloWorld\cf0 ::initPhysical()\
\{\
    \
    \cf7 CCSize\cf0  s = \cf7 CCDirector\cf0 ::\cf8 sharedDirector\cf0 ()->\cf8 getWinSize\cf0 ();\
\
    \cf2 //
\f1 \'b4\'b4\'bd\'a8\'ca\'c0\'bd\'e7
\f0 \cf0 \
    \cf7 b2Vec2\cf0  gravity;\
    gravity.\cf8 Set\cf0 (\cf6 0.0f\cf0 , -\cf6 10.0f\cf0 );\cf2 //
\f1 \'c9\'e8\'d6\'c3\'d6\'d8\'c1\'a6
\f0 \cf0 \
    \cf7 world\cf0  = \cf5 new\cf0  \cf7 b2World\cf0 (gravity);\cf2 //
\f1 \'b4\'b4\'bd\'a8\'ca\'c0\'bd\'e7
\f0 \cf0 \
    \cf7 world\cf0 ->\cf8 SetAllowSleeping\cf0 (\cf5 true\cf0 );\cf2 //
\f1 \'c9\'e8\'d6\'c3\'ca\'c7\'b7\'f1\'d4\'ca\'d0\'ed\'d0\'dd\'c3\'df
\f0 \cf0 \
    \cf7 world\cf0 ->\cf8 SetContinuousPhysics\cf0 (\cf5 true\cf0 );\cf2 //
\f1 \'ca\'c7\'b7\'f1\'ca\'b9\'d3\'c3\'c1\'ac\'d0\'f8\'ce\'ef\'c0\'ed\'bc\'ec\'b2\'e2
\f0 \cf0 \
    \cf2 //delete world;//
\f1 \'cf\'fa\'bb\'d9\'ca\'c0\'bd\'e7
\f0 \cf0 \
    \
    \cf2 //
\f1 \'b4\'b4\'bd\'a8\'be\'b2\'cc\'ac\'b8\'d5\'cc\'e5
\f0 \cf0 \
    \cf2 //
\f1 \'c9\'f9\'c3\'f7\'d2\'bb\'b8\'f6\'b8\'d5\'cc\'e5\'b6\'a8\'d2\'e5
\f0 \cf0 \
    \cf7 b2BodyDef\cf0  groundBodyDef;\
    groundBodyDef.\cf7 position\cf0 .\cf8 Set\cf0 (\cf6 0.0f\cf0 ,\cf6 0.0f\cf0 );\
    \cf2 //
\f1 \'b8\'f9\'be\'dd\'b8\'d5\'cc\'e5\'b6\'a8\'d2\'e5\'b4\'b4\'bd\'a8\'b8\'d5\'cc\'e5
\f0 \cf0 \
    \cf7 b2Body\cf0  * groundBody = \cf7 world\cf0 ->\cf8 CreateBody\cf0 (&groundBodyDef);\
    \cf2 //
\f1 \'c9\'f9\'c3\'f7\'d2\'bb\'b8\'f6\'d6\'b1\'cf\'df\'d0\'ce\'d7\'b4
\f0 \cf0 \
    \cf7 b2EdgeShape\cf0  groundBox;\
    groundBox.\cf8 Set\cf0 (\cf7 b2Vec2\cf0 (\cf6 0\cf0 ,\cf6 0\cf0 ),\cf7 b2Vec2\cf0 (s.\cf7 width\cf0 /\cf6 32\cf0 ,\cf6 0\cf0 ));\
    groundBody->\cf8 CreateFixture\cf0 (&groundBox,\cf6 0\cf0 );\
    \cf2 // top\cf0 \
    groundBox.\cf8 Set\cf0 (\cf7 b2Vec2\cf0 (\cf6 0\cf0 ,s.\cf7 height\cf0 /\cf6 32\cf0 ),\cf7 b2Vec2\cf0 (s.\cf7 width\cf0 /\cf6 32\cf0 ,s.\cf7 height\cf0 /\cf6 32\cf0 ));\
    groundBody->\cf8 CreateFixture\cf0 (&groundBox,\cf6 0\cf0 );\
    \cf2 // left\cf0 \
    groundBox.\cf8 Set\cf0 (\cf7 b2Vec2\cf0 (\cf6 0\cf0 ,s.\cf7 height\cf0 /\cf6 32\cf0 ),\cf7 b2Vec2\cf0 (\cf6 0\cf0 ,\cf6 0\cf0 ));\
    groundBody->\cf8 CreateFixture\cf0 (&groundBox,\cf6 0\cf0 );\
    \cf2 // right\cf0 \
    groundBox.\cf8 Set\cf0 (\cf7 b2Vec2\cf0 (s.\cf7 width\cf0 /\cf6 32\cf0 ,s.\cf7 height\cf0 /\cf6 32\cf0 ), \cf7 b2Vec2\cf0 (s.\cf7 width\cf0 /\cf6 32\cf0 ,\cf6 0\cf0 ));\
    groundBody->\cf8 CreateFixture\cf0 (&groundBox,\cf6 0\cf0 );\
    \
    \
    \cf7 b2BodyDef\cf0  bodyDef;\
    bodyDef.\cf7 type\cf0  = \cf8 b2_dynamicBody\cf0 ;\cf2 //
\f1 \'c4\'ac\'c8\'cf\'ce\'aa\'be\'b2\'cc\'ac\'b5\'c4\'a3\'ac\'d5\'e2\'c0\'ef\'d0\'e8\'d2\'aa\'c9\'e8\'d6\'c3\'ce\'aa\'b6\'af\'cc\'ac\'b5\'c4
\f0 \cf0 \
    bodyDef.\cf7 position\cf0 .\cf8 Set\cf0 (\cf6 0.0f\cf0 , \cf6 4.0f\cf0 );\
    \cf7 b2Body\cf0 * body =\cf7 world\cf0 ->\cf8 CreateBody\cf0 (&bodyDef);\
    \cf7 b2PolygonShape\cf0  dynamicBox;\
    dynamicBox.\cf8 SetAsBox\cf0 (\cf6 1.0f\cf0 , \cf6 1.0f\cf0 );\
    \cf7 b2FixtureDef\cf0  fixtureDef;\
    fixtureDef.\cf7 shape\cf0  = &dynamicBox;\
    fixtureDef.\cf7 density\cf0  = \cf6 1.0f\cf0 ;\
    fixtureDef.\cf7 friction\cf0  = \cf6 0.3f\cf0 ;\
    \
    body->\cf8 CreateFixture\cf0 (&fixtureDef);\
\}\
\cf5 void\cf0  \cf7 HelloWorld\cf0 ::addNewSpriteAtPosition(\cf7 CCPoint\cf0  position)\
\{\
    \cf7 PhysicsSprite\cf0  * sprite = \cf5 new\cf0  \cf7 PhysicsSprite\cf0 ();\
    sprite->\cf8 setPosition\cf0 (position);\
    \cf5 this\cf0 ->\cf8 addChild\cf0 (sprite);\
    \cf2 //
\f1 \'c9\'f9\'c3\'f7\'b8\'d5\'cc\'e5
\f0 \cf0 \
    \cf7 b2BodyDef\cf0  bodyDef;\
    \cf2 //
\f1 \'b8\'d5\'cc\'e5\'c0\'e0\'d0\'cd
\f0 \cf0 \
    bodyDef.\cf7 type\cf0  = \cf8 b2_dynamicBody\cf0 ;\
    bodyDef.\cf7 position\cf0 .\cf8 Set\cf0 (position.\cf7 x\cf0 /\cf6 32\cf0 , position.\cf7 y\cf0 /\cf6 32\cf0 );\
    bodyDef.\cf7 userData\cf0  = sprite;\
    \
    \cf7 b2Body\cf0  *body = \cf7 world\cf0 ->\cf8 CreateBody\cf0 (&bodyDef);\
    \cf7 b2PolygonShape\cf0  dynamicBox;\
    dynamicBox.\cf8 SetAsBox\cf0 (\cf6 0.5f\cf0 , \cf6 0.5f\cf0 );\
    \cf2 //
\f1 \'b8\'d5\'cc\'e5\'ba\'cd\'d0\'ce\'d7\'b4\'bd\'e1\'ba\'cf
\f0 \cf0 \
    \cf7 b2FixtureDef\cf0  fixtureDef;\
    fixtureDef.\cf7 shape\cf0  = &dynamicBox;\
    \cf2 //
\f1 \'c3\'dc\'b6\'c8
\f0 \cf0 \
    fixtureDef.\cf7 density\cf0  = \cf6 10.0f\cf0 ;\
    \cf2 //
\f1 \'c4\'a6\'b2\'c1
\f0 \cf0 \
    fixtureDef.\cf7 friction\cf0  =\cf6 0.0f\cf0 ;\
    \cf2 //
\f1 \'bb\'d6\'b8\'b4
\f0 \cf0 \
    fixtureDef.\cf7 restitution\cf0 =\cf6 0.5f\cf0 ;\
    body->\cf8 CreateFixture\cf0 (&fixtureDef);\
    sprite->\cf8 setPhysicsBody\cf0 (body);\
\
\}\
\
\cf2 //  PhysicsSprite.h\cf0 \
\cf2 //  box2d\cf0 \
\
\cf3 #ifndef __box2d__PhysicsSprite__\
#define __box2d__PhysicsSprite__\
\cf0 \
\cf3 #include \cf4 <iostream>\cf3 \
#include \cf4 "cocos2d.h"\cf3 \
#include \cf4 "Box2D/Box2D.h"\cf3 \
USING_NS_CC\cf0 ;\
\
\cf5 class\cf0  PhysicsSprite : \cf5 public\cf0  \cf7 CCSprite\cf0 \
\{\
\cf5 public\cf0 :\
    PhysicsSprite();\
    \cf5 void\cf0  setPhysicsBody(\cf7 b2Body\cf0  * body);\
    \cf5 int\cf0  hp;\
\cf5 private\cf0 :\
    \cf7 b2Body\cf0  * m_pBody;\
    \
\};\
\
\cf3 #endif\
\cf0 \
\
\cf3 #include \cf4 "PhysicsSprite.h"\cf3 \
\cf0 \
PhysicsSprite::PhysicsSprite():m_pBody(\cf5 NULL\cf0 )\
\{\
    \cf5 int\cf0  idx = (CCRANDOM_0_1()>\cf6 0.5\cf0 ?\cf6 0\cf0 :\cf6 1\cf0 );\
    \cf5 int\cf0  idy = (CCRANDOM_0_1()>\cf6 0.5\cf0 ?\cf6 0\cf0 :\cf6 1\cf0 );\
    \cf5 this\cf0 ->initWithFile(\cf4 "blocks.png"\cf0 ,CCRectMake(\cf6 32\cf0 *idx, \cf6 32\cf0 *idy, \cf6 32\cf0 , \cf6 32\cf0 ));\
    hp = \cf6 5\cf0 ;\
\}\
\cf5 void\cf0  PhysicsSprite::setPhysicsBody(b2Body * body)\
\{\
    m_pBody = body;\
\}\
\cf2 //\cf0 \
\cf2 //  MyContactListener.h\cf0 \
\cf2 //  box2d\cf0 \
\cf3 #ifndef __box2d__MyContactListener__\
#define __box2d__MyContactListener__\
\cf0 \
\cf3 #include \cf4 <iostream>\cf3 \
#include \cf4 "cocos2d.h"\cf3 \
#include \cf4 "Box2D/Box2D.h"\cf3 \
\cf5 using\cf0  \cf5 namespace\cf0  \cf10 std\cf0 ;\
\cf5 using\cf0  \cf5 namespace\cf0  \cf7 cocos2d\cf0 ;\
\cf5 class\cf0  MyContactListener:\cf5 public\cf0  \cf7 b2ContactListener\cf0 \
\{\
\cf5 public\cf0 :\
    \cf7 b2World\cf0  *_world;\
    \cf7 CCLayer\cf0  *_layer;\
    MyContactListener();\
    MyContactListener(\cf7 b2World\cf0  *w, \cf7 CCLayer\cf0  *c);\
    \
    ~MyContactListener();\
    \
    \cf5 virtual\cf0  \cf5 void\cf0  BeginContact(\cf7 b2Contact\cf0 * contact);\
    \cf5 virtual\cf0  \cf5 void\cf0  EndContact(\cf7 b2Contact\cf0 * contact);\
    \cf5 virtual\cf0  \cf5 void\cf0  PreSolve(\cf7 b2Contact\cf0 * contact, \cf5 const\cf0  \cf7 b2Manifold\cf0 * oldManifold);\
    \cf5 virtual\cf0  \cf5 void\cf0  PostSolve(\cf7 b2Contact\cf0 * contact, \cf5 const\cf0  \cf7 b2ContactImpulse\cf0 * impulse);\
    \
\};\
\cf3 #endif\cf0 \
\cf2 //\cf0 \
\cf2 //  MyContactListener.cpp\cf0 \
\cf2 //  box2d\cf0 \
\cf3 #include \cf4 "MyContactListener.h"\cf3 \
#include \cf4 "PhysicsSprite.h"\cf3 \
\pard\tx770\pardeftab770\pardirnatural
\cf7 MyContactListener\cf0  :: MyContactListener()\
\{\
    \
\}\
\cf7 MyContactListener\cf0  :: MyContactListener(\cf7 b2World\cf0  *w, \cf7 CCLayer\cf0  *c)\
\{\
    \cf7 _world\cf0  = w;\
    \cf7 _layer\cf0  = c;\
\}\
\cf7 MyContactListener\cf0  :: ~MyContactListener()\
\{\
    \
\}\
\
\pard\tx770\pardeftab770\pardirnatural
\cf5 void\cf0  \cf7 MyContactListener\cf0  :: BeginContact(\cf7 b2Contact\cf0  *contact)\
\{\
    \cf8 CCLog\cf0 (\cf4 "beginContact"\cf0 );\
\}\
\cf5 void\cf0  \cf7 MyContactListener\cf0 :: EndContact(\cf7 b2Contact\cf0  *contact)\
\{\
    \cf8 CCLog\cf0 (\cf4 "EndContact"\cf0 );\
\}\
\cf5 void\cf0  \cf7 MyContactListener\cf0 :: PreSolve(\cf7 b2Contact\cf0  *contact, \cf5 const\cf0  \cf7 b2Manifold\cf0  *oldManifold)\
\{\
    \cf8 CCLog\cf0 (\cf4 "Presolve"\cf0 );\
\}\
\cf5 void\cf0  \cf7 MyContactListener\cf0 :: PostSolve(\cf7 b2Contact\cf0  *contact, \cf5 const\cf0  \cf7 b2ContactImpulse\cf0  *impulse)\
\{\
    \cf2 // solver
\f1 \'bc\'c6\'cb\'e3\'cd\'ea\'b3\'c9\'ba\'f3\'b5\'f7\'d3\'c3\'b5\'c4\'ba\'af\'ca\'fd
\f0 \cf0 \
    \cf5 float\cf0  force = impulse->\cf7 normalImpulses\cf0 [\cf6 0\cf0 ];\
    \cf5 if\cf0  (force > \cf6 2\cf0 )\
    \{\
        \cf7 PhysicsSprite\cf0  *spriteA = (\cf7 PhysicsSprite\cf0  *)contact->\cf8 GetFixtureA\cf0 ()->\cf8 GetBody\cf0 ()->\cf8 GetUserData\cf0 ();\
        \cf7 PhysicsSprite\cf0  *spriteB = (\cf7 PhysicsSprite\cf0  *)contact->\cf8 GetFixtureB\cf0 ()->\cf8 GetBody\cf0 ()->\cf8 GetUserData\cf0 ();\
        \cf5 if\cf0  (spriteA && spriteB)\
        \{\
            spriteA->\cf7 hp\cf0 --;\
            spriteB->\cf7 hp\cf0 --;\
        \}\
    \}\
\}\
\
\
\
\
\
\
\
\
}